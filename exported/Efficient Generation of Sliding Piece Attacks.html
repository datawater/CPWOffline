<!DOCTYPE html>

<html class="client-nojs" dir="ltr" lang="en">
<head>
<meta charset="utf-8"/>
<title>Efficient Generation of Sliding Piece Attacks - Chessprogramming wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Efficient_Generation_of_Sliding_Piece_Attacks","wgTitle":"Efficient Generation of Sliding Piece Attacks","wgCurRevisionId":5310,"wgRevisionId":5310,"wgArticleId":3625,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Efficient_Generation_of_Sliding_Piece_Attacks","wgRelevantArticleId":3625,"wgRequestId":"Zp7DSwMLGU3EphdnCkJWAwAAAAo","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgPreferredVariant":"en","wgMFExpandAllSectionsUserOption":false,"wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false}});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"loading","user.tokens":"loading","ext.cite.styles":"ready","ext.FenTT.styles":"ready","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.options@0bhc5ha",function($,jQuery,require,module){mw.user.options.set([]);});mw.loader.implement("user.tokens@0kthzed",function ( $, jQuery, require, module ) {
mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});/*@nomin*/

});mw.loader.load(["ext.cite.a11y","site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link href="/load.php?debug=false&amp;lang=en&amp;modules=ext.FenTT.styles%7Cext.cite.styles%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;printable=1&amp;skin=vector" rel="stylesheet"/>
<script async="" src="/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;printable=1&amp;skin=vector"></script>
<meta content="" name="ResourceLoaderDynamicStyles"/>
<link href="/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;printable=1&amp;skin=vector" rel="stylesheet"/>
<meta content="MediaWiki 1.30.1" name="generator"/>
<meta content="noindex,follow" name="robots"/>
<link href="/images/favicon.ico" rel="shortcut icon"/>
<link href="/opensearch_desc.php" rel="search" title="Chessprogramming wiki (en)" type="application/opensearchdescription+xml"/>
<link href="https://www.chessprogramming.org/api.php?action=rsd" rel="EditURI" type="application/rsd+xml"/>
<link href="/Chessprogramming:About" rel="license"/>
<link href="/index.php?title=Special:RecentChanges&amp;feed=atom" rel="alternate" title="Chessprogramming wiki Atom feed" type="application/atom+xml"/>
<!--[if lt IE 9]><script src="/resources/lib/html5shiv/html5shiv.min.js?40bd4"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Efficient_Generation_of_Sliding_Piece_Attacks rootpage-Efficient_Generation_of_Sliding_Piece_Attacks skin-vector action-view"> <div class="noprint" id="mw-page-base"></div>
<div class="noprint" id="mw-head-base"></div>
<div class="mw-body" id="content" role="main">
<a id="top"></a>
<div class="mw-indicators mw-body-content">
</div>
<h1 class="firstHeading" id="firstHeading" lang="en">Efficient Generation of Sliding Piece Attacks</h1>
<div class="mw-body-content" id="bodyContent">
<div class="noprint" id="siteSub">From Chessprogramming wiki</div>
<div id="contentSub"></div>
<div class="mw-jump" id="jump-to-nav">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
</div>
<div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="en"><div class="mw-parser-output"><p><b><a href="Main Page.html" title="Main Page">Home</a> * <a href="Conferences.html" title="Conferences">Conferences</a> * <a href="Workshop Chess and Mathematics.html" title="Workshop Chess and Mathematics">Workshop Chess and Mathematics</a> * Efficient Generation of Sliding Piece Attacks</b>
</p><p><br/>
</p>
<div class="floatnone"><a href="http://en.wikipedia.org/wiki/Dresden University of Technology.html" rel="nofollow"><img alt="Logo TU Dresden.svg" class="thumbborder" height="74" src="wikipedia/commons/thumb/f/f9/Logo_TU_Dresden.svg/255px-Logo_TU_Dresden.svg.png" srcset="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f9/Logo_TU_Dresden.svg/383px-Logo_TU_Dresden.svg.png 1.5x, https://upload.wikimedia.org/wikipedia/commons/thumb/f/f9/Logo_TU_Dresden.svg/510px-Logo_TU_Dresden.svg.png 2x" style="vertical-align: text-bottom" width="255"/></a></div>
<p><br/>
</p>
<dl><dd> <u>Fakultät Mathematik und Naturwissenschaften Institut für Numerische Mathematik</u></dd></dl>
<dl><dd> <b>Workshop Chess and Mathematics</b> <sup class="reference" id="cite_ref-1"><a href="#cite note-1">[1]</a></sup></dd>
<dd> <a class="external text" href="https://en.wikipedia.org/wiki/Dresden" rel="nofollow">Dresden</a>, November 21st and 22nd, 2008</dd></dl>
<p><br/>
</p>
<hr/>
<p><a href="Gerd Isenberg.html" title="Gerd Isenberg">Gerd Isenberg</a>, Hattingen
</p><p><span style="font-size: 130%; font-family: Tahoma,Geneva,sans-serif"><b>Efficient generation of Moves and Controls of Sliding Pieces</b></span>
</p><p>Sa., 16:00, TU Dresden, WIL C207<br/>
Attack-Sets as Base for Bitboard Move-generation: Opposed to “None-sliding” pieces, Knight, King and Pawn, whose attacks are determined by its origin square only, sliding piece attacks like Rook-, Bishop- and Queen-attacks are dependend on other pieces as well, which may block the attacking ray in one particular ray-direction. In <a href="Quiescence Search.html" title="Quiescence Search">Quiescence Search</a> the performance of generating (winning) capture moves is crucial. Opposed to classical square-centric board-representations, which require loops over squares, bitboards permit more efficient algorithms in generating sliding attacks.
</p>
<hr/>
<div class="toc" id="toc"><div class="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Bitboard Basics"><span class="tocnumber">1</span> <span class="toctext">Bitboard Basics</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Squares and Bitindex"><span class="tocnumber">1.1</span> <span class="toctext">Squares and Bitindex</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Empty and Universe"><span class="tocnumber">1.2</span> <span class="toctext">Empty and Universe</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Bitboard Board-Definition"><span class="tocnumber">1.3</span> <span class="toctext">Bitboard Board-Definition</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Setwise Operations"><span class="tocnumber">1.4</span> <span class="toctext">Setwise Operations</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Shifts"><span class="tocnumber">1.5</span> <span class="toctext">Shifts</span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="#One Step Only"><span class="tocnumber">1.5.1</span> <span class="toctext">One Step Only</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#Pawn Attacks"><span class="tocnumber">1.5.2</span> <span class="toctext">Pawn Attacks</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-9"><a href="#Bit-Twiddling relying on the Two.27s Complement"><span class="tocnumber">1.6</span> <span class="toctext">Bit-Twiddling relying on the Two's Complement</span></a>
<ul>
<li class="toclevel-3 tocsection-10"><a href="#LS-Bit-Isolation"><span class="tocnumber">1.6.1</span> <span class="toctext">LS-Bit-Isolation</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="#LS-Bit-Reset"><span class="tocnumber">1.6.2</span> <span class="toctext">LS-Bit-Reset</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-12"><a href="#Converting Bitboards to Lists"><span class="tocnumber">1.7</span> <span class="toctext">Converting Bitboards to Lists</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#BitScan"><span class="tocnumber">1.8</span> <span class="toctext">BitScan</span></a>
<ul>
<li class="toclevel-3 tocsection-14"><a href="#De Bruijn Multiplication"><span class="tocnumber">1.8.1</span> <span class="toctext">De Bruijn Multiplication</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#Bitscan by Modulo"><span class="tocnumber">1.8.2</span> <span class="toctext">Bitscan by Modulo</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-16"><a href="#Kindergarten Multiplication"><span class="tocnumber">1.9</span> <span class="toctext">Kindergarten Multiplication</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-17"><a href="#Attack-Sets as Base for Bitboard Move-generation"><span class="tocnumber">2</span> <span class="toctext">Attack-Sets as Base for Bitboard Move-generation</span></a>
<ul>
<li class="toclevel-2 tocsection-18"><a href="#Sliding piece Attacks on the otherwise empty board"><span class="tocnumber">2.1</span> <span class="toctext">Sliding piece Attacks on the otherwise empty board</span></a>
<ul>
<li class="toclevel-3 tocsection-19"><a href="#Ray Attacks"><span class="tocnumber">2.1.1</span> <span class="toctext">Ray Attacks</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="#Line Attacks"><span class="tocnumber">2.1.2</span> <span class="toctext">Line Attacks</span></a></li>
<li class="toclevel-3 tocsection-21"><a href="#Piece attacks"><span class="tocnumber">2.1.3</span> <span class="toctext">Piece attacks</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-22"><a href="#Sliding Attacks by Calculation"><span class="tocnumber">3</span> <span class="toctext">Sliding Attacks by Calculation</span></a>
<ul>
<li class="toclevel-2 tocsection-23"><a href="#Subtraction and Reverse Subtraction of rooks from blockers"><span class="tocnumber">3.1</span> <span class="toctext">Subtraction and Reverse Subtraction of rooks from blockers</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="#Flood Fill Techniques with multiple sliders"><span class="tocnumber">3.2</span> <span class="toctext">Flood Fill Techniques with multiple sliders</span></a>
<ul>
<li class="toclevel-3 tocsection-25"><a href="#Occluded Fill"><span class="tocnumber">3.2.1</span> <span class="toctext">Occluded Fill</span></a></li>
<li class="toclevel-3 tocsection-26"><a href="#Kogge-Stone Parallel Prefix Algorithm"><span class="tocnumber">3.2.2</span> <span class="toctext">Kogge-Stone Parallel Prefix Algorithm</span></a></li>
<li class="toclevel-3 tocsection-27"><a href="#Ray-wise Attacks in one Direction"><span class="tocnumber">3.2.3</span> <span class="toctext">Ray-wise Attacks in one Direction</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-28"><a href="#Lookup Techniques"><span class="tocnumber">4</span> <span class="toctext">Lookup Techniques</span></a>
<ul>
<li class="toclevel-2 tocsection-29"><a href="#Rook Attacks on the first Rank - as a base of occupancy lookup"><span class="tocnumber">4.1</span> <span class="toctext">Rook Attacks on the first Rank - as a base of occupancy lookup</span></a>
<ul>
<li class="toclevel-3 tocsection-30"><a href="#One Byte Only"><span class="tocnumber">4.1.1</span> <span class="toctext">One Byte Only</span></a></li>
<li class="toclevel-3 tocsection-31"><a href="#The Outer Squares"><span class="tocnumber">4.1.2</span> <span class="toctext">The Outer Squares</span></a></li>
<li class="toclevel-3 tocsection-32"><a href="#Other ranks"><span class="tocnumber">4.1.3</span> <span class="toctext">Other ranks</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-33"><a href="#Rotated Bitboards"><span class="tocnumber">4.2</span> <span class="toctext">Rotated Bitboards</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#Kindergarten Bitboards"><span class="tocnumber">4.3</span> <span class="toctext">Kindergarten Bitboards</span></a>
<ul>
<li class="toclevel-3 tocsection-35"><a href="#Ranks and Diagonals"><span class="tocnumber">4.3.1</span> <span class="toctext">Ranks and Diagonals</span></a></li>
<li class="toclevel-3 tocsection-36"><a href="#Files"><span class="tocnumber">4.3.2</span> <span class="toctext">Files</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-37"><a href="#Congruent Modulo Bitboards"><span class="tocnumber">4.4</span> <span class="toctext">Congruent Modulo Bitboards</span></a></li>
<li class="toclevel-2 tocsection-38"><a href="#Magic Bitboards"><span class="tocnumber">4.5</span> <span class="toctext">Magic Bitboards</span></a>
<ul>
<li class="toclevel-3 tocsection-39"><a href="#How it works"><span class="tocnumber">4.5.1</span> <span class="toctext">How it works</span></a></li>
<li class="toclevel-3 tocsection-40"><a href="#Perfect Hashing"><span class="tocnumber">4.5.2</span> <span class="toctext">Perfect Hashing</span></a></li>
<li class="toclevel-3 tocsection-41"><a href="#Sample Code"><span class="tocnumber">4.5.3</span> <span class="toctext">Sample Code</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-42"><a href="#Summary"><span class="tocnumber">5</span> <span class="toctext">Summary</span></a></li>
<li class="toclevel-1 tocsection-43"><a href="#References"><span class="tocnumber">6</span> <span class="toctext">References</span></a></li>
</ul>
</div>
<h1><span class="mw-headline" id="Bitboard_Basics">Bitboard Basics</span></h1>
<p>Bitboards are 64-bit integers and represent a <a class="external text" href="https://en.wikipedia.org/wiki/Finite_set" rel="nofollow">finite set</a> of up to 64 elements - all the <a href="Squares.html" title="Squares">squares</a> of a <a href="Chessboard.html" title="Chessboard">chessboard</a> with specific boolean properties of those squares. For instance whether squares are empty or occupied, or occupied by a specific kind of piece - or which is the main topic of this talk, whether a square is controlled or attacked (defended) by a specific kind of piece, especially attacked by sliding pieces.
</p>
<h2><span class="mw-headline" id="Squares_and_Bitindex">Squares and Bitindex</span></h2>
<p><i>see main article <a href="Square Mapping Considerations.html" title="Square Mapping Considerations">Square Mapping Considerations</a></i>
</p><p>There is a <a class="external text" href="https://en.wikipedia.org/wiki/Bijection" rel="nofollow">bijective</a> one-to-one correspondence between bits of a bitboard and the squares of a board. There are 64! different mappings, but most commonly bits are enumerated "in order" along ranks or files (orthogonal). Some programs (<a href="Rotated Bitboards.html" title="Rotated Bitboards">Rotated Bitboards</a>) keep redundant mappings and also enumerate consecutive bits along the diagonals or anti-diagonals.
</p><p><i>If not stated otherwise, we further rely on Little-Endian Rank-File Mapping.</i>
</p>
<div class="floatnone"><a class="image" href="File:BBUniverse.jpg.html"><img alt="BBUniverse.jpg" class="thumbborder" height="385" src="images/0/0d/BBUniverse.jpg" style="vertical-align: text-bottom" width="400"/></a></div>
<p>with following relations:
</p>
<pre>
squareIndex {0..63} = 8*rankIndex + fileIndex;
rankIndex   {0..7}  = squareIndex div 8; // squareIndex &gt;&gt; 3;
fileIndex   {0..7}  = squareIndex mod 8; // squareIndex &amp; 7;
</pre>
<p>Diagonals may be enumerated in various ways determined by the difference of rankIndex and fileIndex:
</p>
<pre>
DiagonalIndex {0..15} = (rankIndex - fileIndex) &amp; 15;
\f  0  1  2  3  4  5  6  7
r_________________________
7 | 7  6  5  4  3  2  1  0
6 | 6  5  4  3  2  1  0 15
5 | 5  4  3  2  1  0 15 14
4 | 4  3  2  1  0 15 14 13
3 | 3  2  1  0 15 14 13 12
2 | 2  1  0 15 14 13 12 11
1 | 1  0 15 14 13 12 11 10
0 | 0 15 14 13 12 11 10  9
</pre>
<p>Anti-Diagonals may be enumerated in various ways determined by the sum of rankIndex and fileIndex:
</p>
<pre>
AntiDiagonalIndex {0..15} = (rankIndex + fileIndex) ^ 7; // xor
\f  0  1  2  3  4  5  6  7
r_________________________
7 | 0 15 14 13 12 11 10  9
6 | 1  0 15 14 13 12 11 10
5 | 2  1  0 15 14 13 12 11
4 | 3  2  1  0 15 14 13 12
3 | 4  3  2  1  0 15 14 13
2 | 5  4  3  2  1  0 15 14
1 | 6  5  4  3  2  1  0 15
0 | 7  6  5  4  3  2  1  0
</pre>
<h2><span class="mw-headline" id="Empty_and_Universe">Empty and Universe</span></h2>
<ul><li> The <a class="external text" href="https://en.wikipedia.org/wiki/Empty_set" rel="nofollow">empty set</a> is represented by all bits zero.</li>
<li> The <a class="external text" href="https://en.wikipedia.org/wiki/Universal_set" rel="nofollow">universal set</a> contains all elements by setting all bits to binary one.</li></ul>
<p>The numerical values and set-wise representations of those sets, and how the appear as a board:
</p>
<pre>
empty set E = 0      universal set U   = 2^64 - 1 or ~0
 set-wise   = {}      set-wise         = {a1, b1, c1, d1, ....., e8, f8, g8, h8}
                      hexadecimal      = 0xffffffffffffffff
                      unsigned decimal = 18,446,744,073,709,551,615
. . . . . . . .      1 1 1 1 1 1 1 1
. . . . . . . .      1 1 1 1 1 1 1 1
. . . . . . . .      1 1 1 1 1 1 1 1
. . . . . . . .      1 1 1 1 1 1 1 1
. . . . . . . .      1 1 1 1 1 1 1 1
. . . . . . . .      1 1 1 1 1 1 1 1
. . . . . . . .      1 1 1 1 1 1 1 1
. . . . . . . .      1 1 1 1 1 1 1 1
</pre>
<h2><span class="mw-headline" id="Bitboard_Board-Definition">Bitboard Board-Definition</span></h2>
<p><i>see main article <a href="Bitboard Board-Definition.html" title="Bitboard Board-Definition">Bitboard Board-Definition</a></i>
</p><p>To represent the board we typically need one bitboard for each <a href="Pieces.html" title="Pieces">piece-type</a> and <a href="Color.html" title="Color">color</a> - likely encapsulated inside a class or structure, or as an array of bitboards as part of a <a href="Chess Position.html" title="Chess Position">position</a> object. A one-bit inside a bitboard implies the existence of a piece of this piece-type on a certain <a href="Squares.html" title="Squares">square</a> - one to one associated by the bit-position.
</p>
<pre>
               pieces
   white                  black            occupied               empty
. . . . . . . .     1 . 1 1 . 1 1 .     1 . 1 1 . 1 1 .     . 1 . . 1 . . 1
. . . . . . . .     . . 1 . 1 1 1 1     . . 1 . 1 1 1 1     1 1 . 1 . . . .
. . . . . . . .     1 . . . . . . .     1 . . . . . . .     . 1 1 1 1 1 1 1
. . . . . . . .     . 1 . 1 1 . . .     . 1 . 1 1 . . .     1 . 1 . . 1 1 1
. . . . . . . .     . . . . . . . .     . . . . . . . .     1 1 1 1 1 1 1 1
. 1 1 . . . . .     . . . . . . . .     . 1 1 . . . . .     1 . . 1 1 1 1 1
1 1 . 1 . 1 1 1     . . . . . . . .     1 1 . 1 . 1 1 1     . . 1 . 1 . . .
1 1 1 1 1 . 1 .     . . . . . . . .     1 1 1 1 1 . 1 .     . . . . . 1 . 1
</pre>
<dl><dd><dl><dd> <table class="fentt" style="font-size:24pt"><tr><td class="board" style="width: 8em;"><div class="board"><div class="sq">    <br/>    <br/>    <br/>    <br/>    <br/>    <br/>    <br/>    <br/></div><div class="pcbg">   <br/>   <br/>       <br/>     <br/>        <br/>      <br/>  <br/>  <br/></div><div class="pcfg">♜ ♝♛ ♜♚ <br/>  ♟ ♝♟♟♟<br/>♟       <br/> ♟ ♞♟   <br/>        <br/> ♗♙     <br/>♙♙ ♙ ♙♙♙<br/>♖♘♗♕♖ ♔ <br/></div></div></td></tr></table></dd></dl></dd></dl>
<pre>
               pawns                                  knights
   white                  black            white                  black
. . . . . . . .     . . . . . . . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . . 1 . . 1 1 1     . . . . . . . .     . . . . . . . .
. . . . . . . .     1 . . . . . . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . 1 . . 1 . . .     . . . . . . . .     . . . 1 . . . .
. . . . . . . .     . . . . . . . .     . . . . . . . .     . . . . . . . .
. . 1 . . . . .     . . . . . . . .     . . . . . . . .     . . . . . . . .
1 1 . 1 . 1 1 1     . . . . . . . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .     . 1 . . . . . .     . . . . . . . .
              bishops                                  rooks
   white                   black           white                  black
. . . . . . . .     . . 1 . . . . .     . . . . . . . .     1 . . . . 1 . .
. . . . . . . .     . . . . 1 . . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .     . . . . . . . .     . . . . . . . .
. 1 . . . . . .     . . . . . . . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .     . . . . . . . .     . . . . . . . .
. . 1 . . . . .     . . . . . . . .     1 . . . 1 . . .     . . . . . . . .
               queens                                  kings
   white                   black           white                  black
. . . . . . . .     . . . 1 . . . .     . . . . . . . .     . . . . . . 1 .
. . . . . . . .     . . . . . . . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .     . . . . . . . .     . . . . . . . .
. . . 1 . . . .     . . . . . . . .     . . . . . . 1 .     . . . . . . . .
</pre>
<h2><span class="mw-headline" id="Setwise_Operations">Setwise Operations</span></h2>
<p><i>see main article <a href="General Setwise Operations.html" title="General Setwise Operations">General Setwise Operations</a></i>
</p><p><a class="external text" href="https://en.wikipedia.org/wiki/Boolean_algebra" rel="nofollow">Boolean algebra</a> is an algebraic structure that captures essential properties of both set operations and logic operations. Specifically, it deals with the set operations of <b>intersection</b>, <b>union</b>, <b>complement</b> - and the bitwise boolean operations of <b>AND, OR, NOT</b>. Bitwise boolean operations on 64-bit words are in fact 64 parallel operations on each bit.
</p><p>Assume we have an attack set of a <a href="Queen.html" title="Queen">queen</a>, and like to know whether the queen attacks opponent <a href="Pieces.html" title="Pieces">pieces</a> it may <a href="Captures.html" title="Captures">capture</a>, we need to 'and' the queen-attacks with the set of opponent pieces.
</p>
<pre>
queen attacks    &amp;  opponent pieces  =  attacked pieces
. . . . . . . .     1 . . 1 1 . . 1     . . . . . . . .
. . . 1 . . 1 .     1 . 1 1 1 1 1 .     . . . 1 . . 1 .
. 1 . 1 . 1 . .     . 1 . . . . . 1     . 1 . . . . . .
. . 1 1 1 . . .     . . . . . . . .     . . . . . . . .
1 1 1 * 1 1 1 .  &amp;  . . . * . . 1 .  =  . . . * . . 1 .
. . 1 1 1 . . .     . . . . . . . .     . . . . . . . .
. . . 1 . 1 . .     . . . . . . . .     . . . . . . . .
. . . 1 . . . .     . . . . . . . .     . . . . . . . .
</pre>
<h2><span class="mw-headline" id="Shifts">Shifts</span></h2>
<p>Shift acts like a multiplication (shift left) or division (shift right) by a power of two.
With orthogonal square mapping, shift with appropriate ray directions amounts of {1,7,8,9} are used to "move" the pieces one step in that direction, or to generate their square controls set-wise.
</p><p>In the 8*8 board centric world with one scalar square-coordinate 0..63, each of the max eight neighboring squares can be determined by adding an offset for each direction. For border squares one has to care about overflows and wraps from a-file to h-file or vice versa. Some conditional code is needed to avoid that. Such code is usually part of move generation for particular pieces.
</p><p>The mentioned square mapping implies following eight ray-directions as a compass-rose:
</p>
<pre>
  northwest    north   northeast
  noWe         nort         noEa
          +7    +8    +9
              \  |  /
  west    -1 &lt;-  0 -&gt; +1    east
              /  |  \
          -9    -8    -7
  soWe         sout         soEa
  southwest    south   southeast
</pre>
<p>In the set-wise world of bitboards, where a square as member of a set is determined by an appropriate one-bit 2^square, the operation to apply such movements is shifting.
</p><p>One has to consider wraps, which requires one further intersection.
</p><p><i>To be aware of their scalar 64-bit origin, we use so far a type defined unsigned integer U64 in our <a href="C.html" title="C">C</a> or <a href="Cpp.html" title="Cpp">C++</a> source snippets, the scalar 64-bit long in <a href="Java.html" title="Java">Java</a>. Feel free to define a distinct type or wrap U64 into classes for better abstraction and type-safety during compile time. The macro C64 will append a suffix to 64-bit constants as required by some compilers</i>:
</p>
<pre>
typedef unsigned __int64 U64;    // for the old microsoft compilers
typedef unsigned long long  U64; // supported by MSC 13.00+ and C99
#define C64(constantU64) constantU64##ULL
</pre>
<h3><span class="mw-headline" id="One_Step_Only">One Step Only</span></h3>
<p>The advantage with bitboards is, that the shift applies to all set bits in parallel, e.g. with all pawns. Vertical shifts by +-8 don't need any under- or overflow conditions since bits simply fall out and disappear.
</p>
<pre>
U64 soutOne (U64 b) {return  b &gt;&gt; 8;}
U64 nortOne (U64 b) {return  b &lt;&lt; 8;}
</pre>
<p>Wraps from a-file to h-file or vice versa may be considered by only shifting subsets which may not wrap. Thus we can mask off the a- or h-file before or after a +-1,7,9 shift:
</p>
<pre>
const U64 notAFile = 0xfefefefefefefefe; // ~0x0101010101010101
const U64 notHFile = 0x7f7f7f7f7f7f7f7f; // ~0x8080808080808080
</pre>
<p>Post-shift masks, ...
</p>
<pre>
U64 eastOne (U64 b) {return (b &lt;&lt; 1) &amp; notAFile;}
U64 noEaOne (U64 b) {return (b &lt;&lt; 9) &amp; notAFile;}
U64 soEaOne (U64 b) {return (b &gt;&gt; 7) &amp; notAFile;}
U64 westOne (U64 b) {return (b &gt;&gt; 1) &amp; notHFile;}
U64 soWeOne (U64 b) {return (b &gt;&gt; 9) &amp; notHFile;}
U64 noWeOne (U64 b) {return (b &lt;&lt; 7) &amp; notHFile;}
</pre>
<h3><span class="mw-headline" id="Pawn_Attacks">Pawn Attacks</span></h3>
<p><i>see main article <a href="Pawn Attacks (Bitboards).html" title="Pawn Attacks (Bitboards)">Pawn Attacks (Bitboards)</a></i>
</p><p>Pawn Attacks set-wise as application of One Step Only.
</p>
<pre>
 white pawns       white pawns &lt;&lt; 9  &amp;       notAFile     ==      noEaOne
. . . . . . . .     . . . . . . . .      . 1 1 1 1 1 1 1      . . . . . . . .
. . . . . . . .     . . . . . . . .      . 1 1 1 1 1 1 1      . . . . . . . .
. . . . . . . .     . . . . . . . .      . 1 1 1 1 1 1 1      . . . . . . . .
. . . . . . . .     . . . . . . . .      . 1 1 1 1 1 1 1      . . . . . . . .
. . . . . . . .     h . . c . . . .      . 1 1 1 1 1 1 1      . . . c . . . .
. . c . . . . .     . a b . d . f g      . 1 1 1 1 1 1 1      . a b . d . f g
a b . d . f g h     . . . . . . . .      . 1 1 1 1 1 1 1      . . . . . . . .
. . . . . . . .     / . . . . . . .      . 1 1 1 1 1 1 1      / . . . . . . .

 white pawns       white pawns &lt;&lt; 7  &amp;       notHFile     ==     noWeOne
. . . . . . . .     . . . . . . . .      1 1 1 1 1 1 1 .      . . . . . . . .
. . . . . . . .     . . . . . . . .      1 1 1 1 1 1 1 .      . . . . . . . .
. . . . . . . .     . . . . . . . .      1 1 1 1 1 1 1 .      . . . . . . . .
. . . . . . . .     . . . . . . . .      1 1 1 1 1 1 1 .      . . . . . . . .
. . . . . . . .     . c . . . . . .      1 1 1 1 1 1 1 .      . c . . . . . .
. . c . . . . .     b . d . f g h .      1 1 1 1 1 1 1 .      b . d . f g h .
a b . d . f g h     . . . . . . . a      1 1 1 1 1 1 1 .      . . . . . . . .
. . . . . . . .     . . . . . . . \      1 1 1 1 1 1 1 .      . . . . . . . \

 white pawns                                                 Union (1 == double attacks)
. . . . . . . .                                               . . . . . . . .
. . . . . . . .                                               . . . . . . . .
. . . . . . . .                                               . . . . . . . .
. . . . . . . .                                               . . . . . . . .
. . . . . . . .                                               . c . c . . . .
. . c . . . . .                                               b a 1 . 1 g 1 g
a b . d . f g h                                               . . . . . . . .
. . . . . . . .                                               . . . . . . . .
</pre>
<h2><span class="mw-headline" id="Bit-Twiddling_relying_on_the_Two.27s_Complement">Bit-Twiddling relying on the Two's Complement</span></h2>
<h3><span class="mw-headline" id="LS-Bit-Isolation">LS-Bit-Isolation</span></h3>
<p>Intersection with its Two's Complement isolates the least significant one bit:
</p>
<pre>
With some arbitrary sample set:
      x          &amp;        -x         =     LS1B_of_x
. . . . . . . .     1 1 1 1 1 1 1 1     . . . . . . . .
. . 1 . 1 . . .     1 1 . 1 . 1 1 1     . . . . . . . .
. 1 . . . 1 . .     1 . 1 1 1 . 1 1     . . . . . . . .
. . . . . . . .     1 1 1 1 1 1 1 1     . . . . . . . .
. 1 . . . 1 . .  &amp;  1 . 1 1 1 . 1 1  =  . . . . . . . .
. . 1 . 1 . . .     . . 1 1 . 1 1 1     . . 1 . . . . .
. . . . . . . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .     . . . . . . . .
</pre>
<h3><span class="mw-headline" id="LS-Bit-Reset">LS-Bit-Reset</span></h3>
<p>Intersection with its Ones' Decrement resets the least significant one bit:
</p>
<pre>
      x          &amp;      (x-1)        =  x_with_reset_LS1B
. . . . . . . .     . . . . . . . .     . . . . . . . .
. . 1 . 1 . . .     . . 1 . 1 . . .     . . 1 . 1 . . .
. 1 . . . 1 . .     . 1 . . . 1 . .     . 1 . . . 1 . .
. . . . . . . .     . . . . . . . .     . . . . . . . .
. 1 . . . 1 . .  &amp;  . 1 . . . 1 . .  =  . 1 . . . 1 . .
. . 1 . 1 . . .     1 1 . . 1 . . .     . . . . 1 . . .
. . . . . . . .     1 1 1 1 1 1 1 1     . . . . . . . .
. . . . . . . .     1 1 1 1 1 1 1 1     . . . . . . . .
</pre>
<p>... since two's complement (-x) and ones' decrement (x-1) are complement sets.
</p>
<h2><span class="mw-headline" id="Converting_Bitboards_to_Lists">Converting Bitboards to Lists</span></h2>
<p><i>see main article <a href="Bitboard Serialization.html" title="Bitboard Serialization">Bitboard Serialization</a> and <a href="Traversing Subsets of a Set.html" title="Traversing Subsets of a Set">Traversing Subsets of a Set</a></i>
</p><p>At some point bitboards require serialization - for instance if we need to process move-target sets to generate moves. Thanks to the Two's Complement, isolation and reset is cheap. To determine the bit- or square-index in the 0..63 range is tad more work ...
</p>
<pre>
while ( x ) {
   *list++  = log2OfPowerOfTwo (x &amp; -x); // determine bit index, also referred as BitScan
   x &amp;= x-1; // reset LS1B
}
</pre>
<p>or alternatively
</p>
<pre>
while ( x ) {
   *list++  = bitScanForward(x); // determine bit index of least significant one bit
   x &amp;= x-1; // reset LS1B
}
</pre>
<h2><span class="mw-headline" id="BitScan">BitScan</span></h2>
<p><i>see main article <a href="BitScan.html" title="BitScan">BitScan</a></i>
</p><p>Despite recent processors have hardware instruction for bitScan, two hashing methods are mentioned to determine the base two logarithm of a single populated Bitboard. One hash-index is based on multiplication and shift, while the second one is determined by modulo. As we will see, both techniques also appear in hashing of multiple bits of a line.
</p>
<h3><span class="mw-headline" id="De_Bruijn_Multiplication">De Bruijn Multiplication</span></h3>
<p>The classical <b>De Bruijn</b> bitscan, as described by <a href="Charles Leiserson.html" title="Charles Leiserson">Leiserson et al.</a> <sup class="reference" id="cite_ref-2"><a href="#cite note-2">[2]</a></sup>, to determine the <a href="General Setwise Operations.html#TheLeastSignificantOneBitLS1B" title="General Setwise Operations">LS1B</a> index by <a href="Hash Table.html#MinimalPerfectHashing" title="Hash Table">minimal perfect hashing</a>. So called <a class="external text" href="https://en.wikipedia.org/wiki/De_Bruijn_sequence" rel="nofollow">De Bruijn sequences</a> were invented by the Dutch mathematician <a href="Nicolaas de Bruijn.html" title="Nicolaas de Bruijn">Nicolaas de Bruijn</a>. A 64-bit De Bruijn sequence contains 64-overlapping unique 6-bit sequences, thus a ring of 64+5 bits. The five hidden "trailing" zeros are in fact common with the five leading zeros. There are 2^26 = 67108864 odd sequences with 6 leading binary zeros and 2^26 even sequences with 5 leading binary zeros, which may be calculated from the odd ones by shifting left one.
</p><p>A multiplication with a power of two value (the isolated <a href="General Setwise Operations.html#TheLeastSignificantOneBitLS1B" title="General Setwise Operations">LS1B</a>) acts like a left shift by it's exponent. Thus, if we multiply a 64-bit De Bruijn sequence with the isolated <a href="General Setwise Operations.html#TheLeastSignificantOneBitLS1B" title="General Setwise Operations">LS1B</a>, we get a unique six bit sequence in the most significant bits. To obtain the bit-index we need to extract these upper six bits by shifting right the product, to lookup an array.
</p><p>See also <a href="De Bruijn Sequence Generator.html" title="De Bruijn Sequence Generator">generating your "private" De Bruijn Bitscan routine</a>.
</p>
<pre>
const int index64[64] = {
   63,  0, 58,  1, 59, 47, 53,  2,
   60, 39, 48, 27, 54, 33, 42,  3,
   61, 51, 37, 40, 49, 18, 28, 20,
   55, 30, 34, 11, 43, 14, 22,  4,
   62, 57, 46, 52, 38, 26, 32, 41,
   50, 36, 17, 19, 29, 10, 13, 21,
   56, 45, 25, 31, 35, 16,  9, 12,
   44, 24, 15,  8, 23,  7,  6,  5
};

/**
* bitScanForward
* @author Charles E. Leiserson
*         Harald Prokop
*         Keith H. Randall
* "Using de Bruijn Sequences to Index a 1 in a Computer Word"
* @param bb bitboard to scan
* @precondition bb != 0
* @return index (0..63) of least significant one bit
*/
int bitScanForward(U64 bb) {
   const U64 debruijn64 = C64(0x07EDD5E59A4E28C2);
   return index64[((bb &amp; -bb) * debruijn64) &gt;&gt; 58];
}
</pre>
<h3><span class="mw-headline" id="Bitscan_by_Modulo">Bitscan by Modulo</span></h3>
<p>Another idea is to apply a modulo operation of the isolated LS1B by the prime number 67 <sup class="reference" id="cite_ref-3"><a href="#cite note-3">[3]</a></sup> <sup class="reference" id="cite_ref-4"><a href="#cite note-4">[4]</a></sup><sup class="reference" id="cite_ref-5"><a href="#cite note-5">[5]</a></sup>. The remainder 0..66 can be used to <a href="Hash Table.html#PerfectHashing" title="Hash Table">perfectly hash</a> the bit-index table. Three gaps are 0, 17, and 34, so the mod 67 can make a branchless trailing zero count.
</p>
<pre>
const int lookup67[67+1] = {
   64,  0,  1, 39,  2, 15, 40, 23,
    3, 12, 16, 59, 41, 19, 24, 54,
    4, -1, 13, 10, 17, 62, 60, 28,
   42, 30, 20, 51, 25, 44, 55, 47,
    5, 32, -1, 38, 14, 22, 11, 58,
   18, 53, 63,  9, 61, 27, 29, 50,
   43, 46, 31, 37, 21, 57, 52,  8,
   26, 49, 45, 36, 56,  7, 48, 35,
    6, 34, 33, -1
};

/**
* trailingZeroCount
* @param bb bitboard to scan
* @return index (0..63) of least significant one bit, 64 if bb is zero
*/
int trailingZeroCount(U64 bb) {
   return lookup67[(bb &amp; -bb) % 67];
}
</pre>
<p>Since div/mod is an expensive instruction, a modulo by constant is likely replaced by reciprocal fixed point multiplication to get the quotient and a second multiplication and difference to get the remainder. Compared with De Bruijn multiplication it is still to slow.
</p>
<h2><span class="mw-headline" id="Kindergarten_Multiplication">Kindergarten Multiplication</span></h2>
<p><i>see main article <a href="Flipping Mirroring and Rotating.html" title="Flipping Mirroring and Rotating">Flipping Mirroring and Rotating</a></i>
</p><p>Multiplication with <b>disjoint</b> intermediate results was nominated as Kindergarten Multiplication.
</p><p>Multiplying the masked A-file with the main-diagonal, maps the file-bits to the 8th rank, similar to a flip about the anti-diagonal A8-H1. Shifting down to the 1st rank, leaves the bits like a 90-degree anti clockwise rotation.
</p>
<pre>
masked bits                             mapped to 8th rank
bits on A-file   *  main-diagonal    =  with garbage     -&gt; 1st rank
A . . . . . . .     . . . . . . . 1     A B C D E F G H     . . . . . . . .
B . . . . . . .     . . . . . . 1 .     B C D E F G H .     . . . . . . . .
C . . . . . . .     . . . . . 1 . .     C D E F G H . .     . . . . . . . .
D . . . . . . .     . . . . 1 . . .     D E F G H . . .  &gt;&gt; . . . . . . . .
E . . . . . . .  *  . . . 1 . . . .  =  E F G H . . . .  56 . . . . . . . .
F . . . . . . .     . . 1 . . . . .     F G H . . . . .     . . . . . . . .
G . . . . . . .     . 1 . . . . . .     G H . . . . . .     . . . . . . . .
H . . . . . . .     1 . . . . . . .     H . . . . . . .     A B C D E F G H
</pre>
<p>That is straight forward multiplication of a masked diagonal or anti-diagonal with the A-file.
To mask the garbage off, we further shift down by 7 ranks.
</p>
<pre>
masked diagonal  *  A-file              mapped
to 8th rank      -&gt;  1st rank
. . . . . . . H     1 . . . . . . .     A B C D E F G H     . . . . . . . .
. . . . . . G .     1 . . . . . . .     A B C D E F G .     . . . . . . . .
. . . . . F . .     1 . . . . . . .     A B C D E F . .  &gt;&gt; . . . . . . . .
. . . . E . . .     1 . . . . . . .     A B C D E . . .  56 . . . . . . . .
. . . D . . . .  *  1 . . . . . . .  =  A B C D . . . .     . . . . . . . .
. . C . . . . .     1 . . . . . . .     A B C . . . . .     . . . . . . . .
. B . . . . . .     1 . . . . . . .     A B . . . . . .     . . . . . . . .
A . . . . . . .     1 . . . . . . .     A . . . . . . .     A B C D E F G H
</pre>
<hr/>
<h1><span class="mw-headline" id="Attack-Sets_as_Base_for_Bitboard_Move-generation">Attack-Sets as Base for Bitboard Move-generation</span></h1>
<p>Opposed to "None-sliding" pieces, Knight, King and Pawn, whose <b>controls</b> or <b>attacks</b> are determined by its origin <b>square</b> only, sliding piece attacks like Rook-, Bishop- and Queen-attacks are dependent on other pieces as well, which may <b>block</b> the attacking ray in one particular ray-direction.
</p><p>In Quiescence Search the performance of generating (winning) capture moves is crucial. Opposed to classical square-centric board-representations, which require loops over squares, bitboards permit more efficient algorithms in generating sliding attacks.
</p>
<h2><span class="mw-headline" id="Sliding_piece_Attacks_on_the_otherwise_empty_board">Sliding piece Attacks on the otherwise empty board</span></h2>
<p><i>see main article <a href="On an empty Board.html" title="On an empty Board">On an empty Board</a></i>
</p><p>Attacks of single sliding pieces on the otherwise empty board or their disjoint subsets on lines or rays are that simple than none sliding pieces. We simply use pre-calculated tables for each piece-type, line or ray, indexed by square-index.
</p>
<h3><span class="mw-headline" id="Ray_Attacks">Ray Attacks</span></h3>
<p>The mentioned square mapping implies following eight ray-directions as a compass-rose:
</p>
<pre>
  northwest    north   northeast
  noWe         nort         noEa
          +7    +8    +9
              \  |  /
  west    -1 &lt;-  0 -&gt; +1    east
              /  |  \
          -9    -8    -7
  soWe         sout         soEa
  southwest    south   southeast
</pre>
<p>Positive Rays:
</p>
<pre>
East (+1)           Nort (+8)            NoEa (+9)           NoWe (+7)
. . . . . . . .     . . . 1 . . . .      . . . . . . . 1     . . . . . . . .
. . . . . . . .     . . . 1 . . . .      . . . . . . 1 .     1 . . . . . . .
. . . . . . . .     . . . 1 . . . .      . . . . . 1 . .     . 1 . . . . . .
. . . . . . . .     . . . 1 . . . .      . . . . 1 . . .     . . 1 . . . . .
. . . R 1 1 1 1     . . . R . . . .      . . . B . . . .     . . . B . . . .
. . . . . . . .     . . . . . . . .      . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .      . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .      . . . . . . . .     . . . . . . . .
</pre>
<p>Negative Rays:
</p>
<pre>
West (-1)           Sout (-8)            SoWe (-9)           SoEa (-7)
. . . . . . . .     . . . . . . . .      . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .      . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .      . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .      . . . . . . . .     . . . . . . . .
1 1 1 R . . . .     . . . R . . . .      . . . B . . . .     . . . B . . . .
. . . . . . . .     . . . 1 . . . .      . . 1 . . . . .     . . . . 1 . . .
. . . . . . . .     . . . 1 . . . .      . 1 . . . . . .     . . . . . 1 . .
. . . . . . . .     . . . 1 . . . .      1 . . . . . . .     . . . . . . 1 .
</pre>
<h3><span class="mw-headline" id="Line_Attacks">Line Attacks</span></h3>
<pre>
Rank                File                 Diagonal            Anti-Diagonal
. . . . . . . .     . . . 1 . . . .      . . . . . . . 1     . . . . . . . .
. . . . . . . .     . . . 1 . . . .      . . . . . . 1 .     1 . . . . . . .
. . . . . . . .     . . . 1 . . . .      . . . . . 1 . .     . 1 . . . . . .
. . . . . . . .     . . . 1 . . . .      . . . . 1 . . .     . . 1 . . . . .
1 1 1 R 1 1 1 1     . . . R . . . .      . . . B . . . .     . . . B . . . .
. . . . . . . .     . . . 1 . . . .      . . 1 . . . . .     . . . . 1 . . .
. . . . . . . .     . . . 1 . . . .      . 1 . . . . . .     . . . . . 1 . .
. . . . . . . .     . . . 1 . . . .      1 . . . . . . .     . . . . . . 1 .
</pre>
<h3><span class="mw-headline" id="Piece_attacks">Piece attacks</span></h3>
<p>Piece attacks are the union of either orthogonal or diagonal lines. Queen attacks are the union of rook- and bishop attacks.
</p>
<pre>
                                   Queen
                               . . . 1 . . . 1
                               1 . . 1 . . 1 .
                               . 1 . 1 . 1 . .
               Rook            . . 1 1 1 . . .         Bishop
           . . . 1 . . . .     1 1 1 Q 1 1 1 1     . . . . . . . 1
           . . . 1 . . . .     . . 1 1 1 . . .     1 . . . . . 1 .
           . . . 1 . . . .     . 1 . 1 . 1 . .     . 1 . . . 1 . .
           . . . 1 . . . .     1 . . 1 . . 1 .     . . 1 . 1 . . .
           1 1 1 R 1 1 1 1                         . . . B . . . .
           . . . 1 . . . .                         . . 1 . 1 . . .
           . . . 1 . . . .                         . 1 . . . 1 . .
           . . . 1 . . . .                         1 . . . . . 1 .
</pre>
<h1><span class="mw-headline" id="Sliding_Attacks_by_Calculation">Sliding Attacks by Calculation</span></h1>
<p>For one single sliding piece, one may consider subtraction from the set of blockers, to determine attack sets. Zeros, that are empty squares, between the nearest blocker and the sliding pieces became "ones", the nearest blocker becomes zero. In fact all flipped bits are the attacked squares in positive ray direction.
</p>
<pre>
 occupied  11000101
 slider    00000100 subset of occupied
 o-s       11000001 resets the slider in occupied
 o-2s      10111101 borrows the one from nearest blocker
 occupied  11000101
 o^(o-2s)  01111000 all flipped bits are the attacks in most significant bit direction
</pre>
<p>To restrict the operations to a certain line, rank file or diagonal, a leading intersection with the line mask is necessary, same for the final result.
</p>
<h2><span class="mw-headline" id="Subtraction_and_Reverse_Subtraction_of_rooks_from_blockers">Subtraction and Reverse Subtraction of rooks from blockers</span></h2>
<p><i>see main article <a href="Subtracting a Rook from a Blocking Piece.html" title="Subtracting a Rook from a Blocking Piece">Subtracting a Rook from a Blocking Piece</a> and <a href="Hyperbola Quintessence.html" title="Hyperbola Quintessence">Hyperbola Quintessence</a></i>
</p><p>With s (sliding piece) single element set and subset of o (occupied):
</p>
<pre>
positiveRayAttacks = o  ^ (o - 2s);
</pre>
<p>The first subtraction resets the siding-piece-bit in occupied.
The second subtraction borrows a one from nearest blocker (if any), and sets all intermediate zero bits (empty squares). The exclusive or gains all flipped bits, which turnes out to be the rook attacks in "positive" attacking direction.
</p><p>For negative directions one needs "reverse" arithmetic (2 + 2 == 1).
</p>
<pre>
with o' = reverse (o)
and  s' = reverse (s)
negativeRayAttacks = reverse (o' ^ (o' - 2s'));
</pre>
<p>Since bit-reversal or any mirroring or flipping is distributive over xor:
</p>
<pre>
reverse(a ^ b) == reverse (a) ^ reverse(b)
</pre>
<p>One can reformulate negative rays
</p>
<pre>
negativeRayAttacks = o  ^  reverse (o' - 2s');
</pre>
<p>which leads to a simplification in the line-attacks, since positiveRayAttacks and negativeRayAttacks are disjoint sets for one particular sliding piece and may be combined by "xor", and o ^ o == 0.
</p>
<pre>
lineAttacks = positiveRayAttacks ^ negativeRayAttacks;
lineAttacks =         o ^ (o-2s) ^ reverse( o'-2s') ^ o
lineAttacks =             (o-2s) ^ reverse( o'-2s')
</pre>
<p>Diagonal or vertical line occupancies need leading and trailing intersection with line-masks. Thanks to the little-endian versus big-endian war, recent processors have appropriate instructions to swap bytes (ranks) inside a 64-bit word for the reverse arithmetic, note that masked files or diagonals have only max one bit per rank:
</p>
<pre>
U64 diagonalAttacks(U64 occ, int sqOfSlider) {
   U64 forward, reverse, slider, lineMask;

   lineMask = diagonalMaskEx[sqOfSlider]; // excludes square of slider
   slider   = singleBitboard[sqOfSlider]; // single bit 1 &lt;&lt; sq, 2^sq

   forward  = occ &amp; lineMask; // also performs the first subtraction by clearing the s in o
   reverse  = byteswap( forward ); // o'-s'
   forward -=         ( slider  ); // o -2s
   reverse -= byteswap( slider  ); // o'-2s'
   forward ^= byteswap( reverse );
   return forward &amp; lineMask;      // mask the line again
}
</pre>
<h2><span class="mw-headline" id="Flood_Fill_Techniques_with_multiple_sliders">Flood Fill Techniques with multiple sliders</span></h2>
<p>Fill approaches determine attacks set-wise for multiple pieces (i.e. rooks and queen(s)) in one particular ray-direction. The flood stops on each particular ray (either 8 ranks or files, or 15 diagonals or anti-diagonals), if a square is not empty.
</p>
<h3><span class="mw-headline" id="Occluded_Fill">Occluded Fill</span></h3>
<p><i>see main article <a href="Dumb7Fill.html" title="Dumb7Fill">Dumb7Fill</a></i>
For sliding piece-attacks one direction step can be repeated seven times, after each shift, intersecting with empty squares accumulating all intermediate results to a union set, which results in an occluded fill set, including the sliding piece but excluding the blocker.
</p>
<pre>
U64 eastOccluded (U64 rooks, U64 empty) {
   empty  = empty &amp; notAFile; // make A-File all occupied, to consider H-A-wraps after shift
   rooks |= empty &amp; (rooks &lt;&lt; 1); // 1. fill
   rooks |= empty &amp; (rooks &lt;&lt; 1); // 2. fill
   rooks |= empty &amp; (rooks &lt;&lt; 1); // 3. fill
   rooks |= empty &amp; (rooks &lt;&lt; 1); // 4. fill
   rooks |= empty &amp; (rooks &lt;&lt; 1); // 5. fill
   rooks |= empty &amp; (rooks &lt;&lt; 1); // 6. fill
   rooks |= empty &amp; (rooks &lt;&lt; 1); // 7. fill // not necessary for further attack generation
   return rooks;
}
</pre>
<h3><span class="mw-headline" id="Kogge-Stone_Parallel_Prefix_Algorithm">Kogge-Stone Parallel Prefix Algorithm</span></h3>
<p><i>see main article <a href="Kogge-Stone Algorithm.html" title="Kogge-Stone Algorithm">Kogge-Stone Algorithm</a> and <a href="Parallel Prefix Algorithms.html" title="Parallel Prefix Algorithms">Parallel Prefix Algorithms</a></i>
Occluded fill might be done more efficiently parallel prefix wise by Kogge-Stone Algorithms:
</p>
<pre>
U64 eastOccluded(U64 rooks, U64 empty) {
   empty  = empty &amp; notAFile; // make A-File all occupied, to consider H-A-wraps after shift
   rooks |= empty &amp; (rooks &lt;&lt; 1);
   empty  = empty &amp; (empty &lt;&lt; 1);
   rooks |= empty &amp; (rooks &lt;&lt; 2);
   empty  = empty &amp; (empty &lt;&lt; 2);
   rooks |= empty &amp; (rooks &lt;&lt; 4);
   return rooks;
}
</pre>
<p>The Kogge-Stone <a href="Parallel Prefix Algorithms.html" title="Parallel Prefix Algorithms">parallel prefix algorithm</a> for sliding piece attack generation was first introduced by <a href="Steffan Westcott.html" title="Steffan Westcott">Steffan Westcott</a> in <a href="CCC.html" title="CCC">CCC</a> <sup class="reference" id="cite_ref-6"><a href="#cite note-6">[6]</a></sup>. It is a parallel prefix approach of a occluded <a href="Dumb7Fill.html" title="Dumb7Fill">dumb7</a> <a class="external text" href="https://en.wikipedia.org/wiki/Flood_fill" rel="nofollow">flood-fill</a>, propagating sliding piece attacks in software like carries of a kogge-stone <a class="external text" href="https://en.wikipedia.org/wiki/Carry_look-ahead_adder" rel="nofollow">hardware adder</a> <sup class="reference" id="cite_ref-7"><a href="#cite note-7">[7]</a></sup>. We need to pass sliders as generator set and the set of empty squares as propagator set. For appropriate attacks we need to shift <a href="General Setwise Operations.html#OneStepOnly" title="General Setwise Operations">one step</a> further, considering wraps.
</p>
<h3><span class="mw-headline" id="Ray-wise_Attacks_in_one_Direction">Ray-wise Attacks in one Direction</span></h3>
<p>For square attack sets, occluded fill sets need to be shifted one more step. Thus, the occluded fill needs one fill cycle less.
</p>
<pre>
U64 eastAttacks (U64 rooks, U64 empty) {
   empty  = empty &amp; notAFile; // make A-File all occupied, to consider H-A-wraps after shift
   rooks |= empty &amp; (rooks &lt;&lt; 1); // 1. fill
   rooks |= empty &amp; (rooks &lt;&lt; 1); // 2. fill
   rooks |= empty &amp; (rooks &lt;&lt; 1); // 3. fill
   rooks |= empty &amp; (rooks &lt;&lt; 1); // 4. fill
   rooks |= empty &amp; (rooks &lt;&lt; 1); // 5. fill
   rooks |= empty &amp; (rooks &lt;&lt; 1); // 6. fill
   return notAFile&amp; (rooks &lt;&lt; 1);
}
</pre>
<p>Because fill-approaches keep distinct ray-directions, there is still a unique source-target square relation. Fill approaches with pure calculation are Cpu-intensive, but require no memory reads. They are a domain of SIMD instruction sets like SSE2 with sixteen 128-bit registers, to process two or four distinct sets (e.g. white and black, sliders and king as queen like meta-slider) per register and several ray-directions simultaneously - e.g. three 128-bit instructions per cycle for core2duo.
</p><p>Keeping distinct ray-directions has some advantages, for instance in determining pinned pieces or discovered checks. Fill-Algorithms are great to feed in line-wise attack sets of single sliders, to determine a progressive mobility on the orthogonal rays, i.e. move targets in two moves, or trajectories against important squares or areas.
</p>
<pre>
 . . . . . . . .
 . . . . \ . . .
 . . . \ . 1 . .
 . . \ . 1 . \ .
 . \ . 1 . \ . .
 . . 1 . \ . . .
 . B . \ . . . .
 . . . . . . . .
</pre>
<hr/>
<h1><span class="mw-headline" id="Lookup_Techniques">Lookup Techniques</span></h1>
<p>Lookup Techniques are used to hash pre-calculated attack-sets of a single pieces by square-index and occupancy of the affected lines.
</p>
<h2><span class="mw-headline" id="Rook_Attacks_on_the_first_Rank_-_as_a_base_of_occupancy_lookup">Rook Attacks on the first Rank - as a base of occupancy lookup</span></h2>
<p><i>see main article <a href="First Rank Attacks.html" title="First Rank Attacks">First Rank Attacks</a></i>
The first <a href="Ranks.html" title="Ranks">rank</a> is the ideal line to introduce occupancy lookups.
</p>
<h3><span class="mw-headline" id="One_Byte_Only">One Byte Only</span></h3>
<p>Assume we (temporary) reduce the chess-board to one <a href="Ranks.html" title="Ranks">rank</a>. Occupancy bitboard is one <a href="Byte.html" title="Byte">byte</a> with up to 256 states. A <a href="Rook.html" title="Rook">rook</a> attack-set from one of the eight <a href="Squares.html" title="Squares">squares</a> (<a href="Files.html" title="Files">file</a>) on this single rank is also only one byte. Thus we can construct an array of bytes[256][8], indexed by all 256 occupancies and 8 files, to lookup the pre-calculated rank-attack bytes.
</p>
<table class="wikitable">
<tr>
<td> <div class="floatnone"><a class="image" href="File:FirstRank.JPG.html"><img alt="FirstRank.JPG" class="thumbborder" height="62" src="images/8/88/FirstRank.JPG" style="vertical-align: text-bottom" width="395"/></a></div>
</td></tr>
<tr>
<td>  Occupancy of the first rank = 01001010B
</td></tr>
<tr>
<td> <div class="floatnone"><a class="image" href="File:FirstRankA.JPG.html"><img alt="FirstRankA.JPG" class="thumbborder" height="62" src="images/5/56/FirstRankA.JPG" style="vertical-align: text-bottom" width="402"/></a></div>
</td></tr>
<tr>
<td>  Rank-attacks ::= f (e-file, Occupancy) = 01110110B
</td></tr></table>
<pre>
BYTE arrFirstRankAttacks256x8[256][8]; // 2048 Bytes = 2KByte

firstRankAttack = arrFirstRankAttacks256x8[rankOccupancy][squareOnRank];
</pre>
<h3><span class="mw-headline" id="The_Outer_Squares">The Outer Squares</span></h3>
<p>If we think about to the occupancy lookup, we may recognize that the outer squares don't matter. There are no more squares behind. The outer squares are either attacked or not - independent from their occupancy state. We can use the <b>six inner bits</b> only as lookup-index with two additional cheap instruction. This reduces the lookup-table by factor of <b>four</b>.
</p>
<pre>
BYTE arrFirstRankAttacks64x8[64][8]; // 512 Bytes = 1/2KByte

firstRankAttack = arrFirstRankAttacks64x8[(rankOccupancy &gt;&gt; 1)&amp; 63][squareOnRank];
</pre>
<h3><span class="mw-headline" id="Other_ranks">Other ranks</span></h3>
<p>It is simple to shift other ranks to the first rank, and to shift back the attack set.
</p>
<h2><span class="mw-headline" id="Rotated_Bitboards">Rotated Bitboards</span></h2>
<p><i>see main article <a href="Rotated Bitboards.html" title="Rotated Bitboards">Rotated Bitboards</a></i>
</p><p><b>Rotated Bitboards</b> are a bitboard move generation technique invented independently by <a href="Robert Hyatt.html" title="Robert Hyatt">Robert Hyatt</a> <sup class="reference" id="cite_ref-8"><a href="#cite note-8">[8]</a></sup> and by <a href="Ernst A. Heinz.html" title="Ernst A. Heinz">Ernst A. Heinz</a> <sup class="reference" id="cite_ref-9"><a href="#cite note-9">[9]</a></sup> with <a href="Peter Gillgasch.html" title="Peter Gillgasch">Peter Gillgasch</a> from the <a href="DarkThought.html" title="DarkThought">DarkThought</a> team. This variation uses rotated copies of the occupancy in order to place bits along a <a href="Files.html" title="Files">file</a> or <a href="Diagonals.html" title="Diagonals">diagonal</a> in adjacent bits. Because of this, these bits can be easily extracted to obtain an occupancy map for a <a href="Ranks.html" title="Ranks">rank</a>, file, or diagonal. This is used, along with the square of a slider, to lookup a bitboard containing attacks in an array.
</p><p>Rotated bitboards are fast to extract the occupancy index and require 32 KByte for each line direction (rank, file, diagonal and anti-diagonal) for the lookup-tables, considering the inner six bits. However, there is more work in updating four occupied bitboards while making or unmaking moves, instead of one. The fast 64-bit multiplication of recent x64 processors (~4-cycles) with a throughput of up to one cycle, makes on the fly calculations of occupied states on files and diagonals more attractive.
</p>
<h2><span class="mw-headline" id="Kindergarten_Bitboards">Kindergarten Bitboards</span></h2>
<p><i>see main article <a href="Kindergarten Bitboards.html" title="Kindergarten Bitboards">Kindergarten Bitboards</a></i>
Kindergarten Bitboards perform a fill-multiplication and uses a shared lookup table for ranks and diagonals.
</p>
<h3><span class="mw-headline" id="Ranks_and_Diagonals">Ranks and Diagonals</span></h3>
<p>Ranks and diagonals - that is their appropriate line-mask by square-index - are first intersected by the occupancy of the whole board. Doesn't matter whether the slider itself is cleared or not - it is redundant anyway, considered by the pre-calculated lookup-table. Since there is only up to one bit per file, the <a href="General Setwise Operations.html#Multiplication" title="General Setwise Operations">north-fill multiplication</a> by the A-file maps the diagonal to the 8th rank. Or - since we only need the inner six bits, we combine the required shift left one by multiplying with the B-file. Shifting right the product by 58 (64-6) leaves the six-bit occupancy-index in the 0..63 range.
</p><p>For instance the diagonal-attacks of a bishop on d4. 'A'-'H' represent the masked occupied bits along this diagonal, which are either zero or one. We need 'B'-'G' as six bit number:
</p>
<pre>
masked line      *  B-File           =  B-G upper six       occupancy 6 bit
. . . . . . . H     . 1 . . . . . .     . A[B C . E F G]    . . . . . . . .
. . . . . . G .     . 1 . . . . . .     . A B C . E F G     . . . . . . . .
. . . . . F . .     . 1 . . . . . .     . A B C . E F .     . . . . . . . .
. . . . E . . .     . 1 . . . . . .     . A B C . E . .  &gt;&gt; . . . . . . . .
. . . . . . . .  *  . 1 . . . . . .  =  . A B C . . . .  58 . . . . . . . .
. . C . . . . .     . 1 . . . . . .     . A B C . . . .     . . . . . . . .
. B . . . . . .     . 1 . . . . . .     . A B . . . . .     . . . . . . . .
A . . . . . . .     . 1 . . . . . .     . A . . . . . .    [B C . E F G]. .
</pre>
<p>The pre-calculated lookup-table contains the attacks of the first rank - but eight copies in each rank or byte. It is indexed by the six bit occupied-state ('B'-'G') and the file of the slider's square. It needs to be intersected with the same line-mask as formerly the occupancy - to map the first rank attack bits to the appropriate line - that's all. Appropriate pre-calculated attack bits are represented by 'a'-'h':
</p>
<pre>
fillUpAttacks[file == 3][B C . E F G]:

8 copies of rank      the attack set
attacks &amp; l-mask  -&gt;  of this line
a b c . e f g h       . . . . . . . h
a b c . e f g h       . . . . . . g .
a b c . e f g h       . . . . . f . .
a b c . e f g h       . . . . e . . .
a b c . e f g h       . . . . . . . .
a b c . e f g h       . . c . . . . .
a b c . e f g h       . b . . . . . .
a b c . e f g h       a . . . . . . .
</pre>
<p>Code spippets.
</p>
<pre>
U64 fillUpAttacks[8][64];  // 4 KByte pre-calculated Lookup table
const U64 bFile = C64(0x0202020202020202);

U64 diagonalAttacks(U64 occ, enumSquare sq) {
   occ = (diagonalMaskEx[sq] &amp; occ) * bFile &gt;&gt; 58;
   return diagonalMaskEx[sq] &amp; fillUpAttacks[sq&amp;7][occ];
}

U64 antiDiagAttacks(U64 occ, enumSquare sq) {
   occ = (antidiagMaskEx[sq] &amp; occ) * bFile &gt;&gt; 58;
   return antidiagMaskEx[sq] &amp; fillUpAttacks[sq&amp;7][occ];
}

U64 rankAttacks(U64 occ, enumSquare sq) {
   occ = (rankMaskEx[sq] &amp; occ) * bFile &gt;&gt; 58;
   return rankMaskEx[sq] &amp; fillUpAttacks[sq&amp;7][occ];
}
</pre>
<h3><span class="mw-headline" id="Files">Files</span></h3>
<p>File attacks need tad more work:
</p>
<pre>
U64 aFileAttacks [8][64];  // 4 KByte
const U64 aFile   = C64(0x0101010101010101);
const U64 diac2h7 = C64(0x0080402010080400);

U64 fileAttacks(U64 occ, enumSquare sq) {
   occ = aFile  &amp; (occ &gt;&gt; (sq&amp;7));
   occ = (diac2h7 *  occ ) &gt;&gt; 58;
   return aFileAttacksx[sq&gt;&gt;3][occ] &lt;&lt; (sq&amp;7);
}
</pre>
<h2><span class="mw-headline" id="Congruent_Modulo_Bitboards">Congruent Modulo Bitboards</span></h2>
<p><i>see main article <a href="Congruent Modulo Bitboards.html" title="Congruent Modulo Bitboards">Congruent Modulo Bitboards</a></i>
</p><p><b>Congruent Modulo Bitboards</b> was introduced by <a href="Trevor Fenner.html" title="Trevor Fenner">Trevor Fenner</a> and <a href="Mark Levene.html" title="Mark Levene">Mark Levene</a> in the <a href="ICGA Journal.html" title="ICGA Journal">ICGA Journal</a> Vol. 31, No. 1 in 2008 <sup class="reference" id="cite_ref-10"><a href="#cite note-10">[10]</a></sup>. While their <a href="Hash Table.html" title="Hash Table">Perfect Hashing</a> approach provides great mathematical insights in <a class="external text" href="https://en.wikipedia.org/wiki/Modulo" rel="nofollow">Congruent Modulo</a> arithmetic, their final conclusion in comparison with <a href="Hashing Dictionaries.html" title="Hashing Dictionaries">Hashing Dictionaries</a>, <a href="Rotated Bitboards.html" title="Rotated Bitboards">Rotated Bitboards</a> and <a href="Magic Bitboards.html" title="Magic Bitboards">Magic Bitboards</a> was criticized by the obvious comparison with <a href="Kindergarten Bitboards.html" title="Kindergarten Bitboards">Kindergarten Bitboards</a> <sup class="reference" id="cite_ref-11"><a href="#cite note-11">[11]</a></sup>.
</p><p>Fenner and Levene use masked line modulo 514 for the diagonals, modulo 257 for the anti-diagonals and mod 258 for files, to calculate the occupied index, but they didn't consider the <a href="First Rank Attacks.html#TheOuterSquares" title="First Rank Attacks">inner six bits</a> for a denser lookup. Of course, tables could made denser by storing indices, but that would require a second indirection. While Fenner and Levene used a <a class="external text" href="https://en.wikipedia.org/wiki/MATLAB" rel="nofollow">Matlab</a> 32-bit implementation to conclude their approach might be competitive, this is how it may be implemented in <a href="C.html" title="C">C</a> by looking up pre-calculated attack-bitboards:
</p>
<pre>
U64 arrCmodDiaAttacks [514][64];  // 257 K
U64 arrCmodAntiAttacks[257][64];
U64 arrCmodFileAttacks[258][64];

U64 diagonalAttacks(U64 occ, enumSquare sq) {
   occ = (diagonalMask[sq] &amp; occ) % 514;
   return arrCmodDiaAttacks[occ][sq];
}

U64 antiDiagAttacks(U64 occ, enumSquare sq) {
   occ = (antiDiagMask[sq] &amp; occ) % 257;
   return arrCmodAntiAttacks[occ][sq];
}

U64 fileAttacks(U64 occ, enumSquare sq) {
   occ = (fileMask[sq] &amp; occ) % 258;
   return arrCmodFileAttacks[occ][sq];
}
</pre>
<h2><span class="mw-headline" id="Magic_Bitboards">Magic Bitboards</span></h2>
<p><i>see main article <a href="Magic Bitboards.html" title="Magic Bitboards">Magic Bitboards</a></i>
</p><p>Magic bitboards uses a multiply-right-shift <a href="Hash Table.html#PerfectHashing" title="Hash Table">perfect hashing</a> algorithm to index a attack bitboard database - which leaves both line-attacks of a bishop or rook in one run.
</p><p>The magic bitboard approach was introduced by <a href="Lasse Hansen.html" title="Lasse Hansen">Lasse Hansen</a> in the <a href="Computer Chess Forums.html" title="Computer Chess Forums">Winboard programming forum</a>. He had the idea to hash the up to twelve relevant occupied bits of <b>both directions</b> of a rook- or bishop movement simultaneously <sup class="reference" id="cite_ref-12"><a href="#cite note-12">[12]</a></sup>.
</p><p><a href="Pradu Kannan.html" title="Pradu Kannan">Pradu Kannan's</a> improvements to Lasse Hansen's initial approach was to introduce a <a href="Java.html" title="Java">Java</a>-like, two-dimensional array with individual size for each square and all it's relevant occupancies <sup class="reference" id="cite_ref-13"><a href="#cite note-13">[13]</a></sup>. Big savings in table-size - since many squares on either orthogonals or diagonals require less bits than others, especially considering the <a href="First Rank Attacks.html#TheOuterSquares" title="First Rank Attacks">inner six bits</a>. While center squares are more dense for rooks, it is the opposite for bishops <sup class="reference" id="cite_ref-14"><a href="#cite note-14">[14]</a></sup>.
</p>
<h3><span class="mw-headline" id="How_it_works">How it works</span></h3>
<p>A magic move-bitboard generation technique consists of four key steps:
</p>
<ol><li> Mask the relevant occupancy bits to form a key. For example if you had a rook on a1, the relevant occupancy bits will be from a2-a7 and b1-g1.</li>
<li> Multiply the key by a "magic number" to obtain an index mapping. This magic number can be generated by brute-force trial and error quite easily although it isn't 100% certain that the magic number is the best possible (see step 3).</li>
<li> Right shift the index mapping by 64-n bits to create an index, where n is the number of bits in the index. A better magic number will have less bits required in the index.</li>
<li> Use the index to reference a preinitialized move database.</li></ol>
<pre>
any consecutive
relevant occupancy                      combination of
bishop b1, 5 bits                       the masked bits
. . . . . . . .     . . . . . . . .     . . .[C D E F G]
. . . . . . . .     . 1 . . . . . .     . . . . . . . .
. . . . . . G .     . 1 . . . . . .     . . . . . . . .
. . . . . F . .     . 1 . . . . . .     . . . . . . . .
. . . . E . . .  *  . 1 . . . . . .  =  . .garbadge . .    &gt;&gt; (64- 5)
. . . D . . . .     . 1 . . . . . .     . . . . . . . .
. . C . . . . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .     . . . . . . . .

any consecutive
relevant occupancy                      combination of
bishop d4, 9 bits                       the masked bits
. . . . . . . .     . . . . . . . .     2 4 5 B C E F G]
. . . . . . G .     . . .some . . .     . . . . . . .[1
. 5 . . . F . .     . . . . . . . .     . . . . . . . .
. . 4 . E . . .     . . .magic. . .     . . . . . . . .
. . . . . . . .  *  . . . . . . . .  =  . .garbadge . .    &gt;&gt; (64- 9)
. . C . 2 . . .     . . .bits . . .     . . . . . . . .
. B . . . 1 . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .     . . . . . . . .

any consecutive
relevant occupancy                      combination of
rook d4, 10 bits                        the masked bits
. . . . . . . .     . . . . . . . .     4 5 6 B C E F G]
. . . 6 . . . .     . . .some . . .     . . . . . .[1 2
. . . 5 . . . .     . . . . . . . .     . . . . . . . .
. . . 4 . . . .     . . .magic. . .     . . . . . . . .
. B C . E F G .  *  . . . . . . . .  =  . .garbadge . .    &gt;&gt; (64-10)
. . . 2 . . . .     . . .bits . . .     . . . . . . . .
. . . 1 . . . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .     . . . . . . . .

any consecutive
relevant occupancy                      combination of
rook a1, 12 bits                        the masked bits
. . . . . . . .     . . . . . . . .     5 6 B C D E F G]
6 . . . . . . .     . . .some . . .     . . . .[1 2 3 4
5 . . . . . . .     . . . . . . . .     . . . . . . . .
4 . . . . . . .     . . .magic. . .     . . . . . . . .
3 . . . . . . .  *  . . . . . . . .  =  . .garbadge . .    &gt;&gt; (64-12)
2 . . . . . . .     . . .bits . . .     . . . . . . . .
1 . . . . . . .     . . . . . . . .     . . . . . . . .
. B C D E F G .     . . . . . . . .     . . . . . . . .
</pre>
<p>The above illustration is correct for the b1 bishop, since it has only one ray and one bit per file and works kindergarten like. In general a one to one mapping of N scattered occupied bits to N consecutive bits is not always possible due to possible overflows. A perfect mapping of N scattered bits to N consecutive bits is likely not minimal for most squares. It requires one or two gaps inside the consecutive N bits, to avoid collisions, blowing up the table size.
</p><p>But the purpose is to perfectly hash attack-sets rather than consecutive occupied bits.
</p><p>The number of distinct attack-sets is much smaller than the relevant occupancies. Thus, with the help of constructive collisions, some initial guess how to map the bits, and/or trial and error, using exactly N bits is always possible. If we try hard enough to maximize constructive collisions - even less.
</p>
<h3><span class="mw-headline" id="Perfect_Hashing">Perfect Hashing</span></h3>
<p>Magic bitboards applies <a href="Hash Table.html#PerfectHashing" title="Hash Table">perfect hashing</a>. A <a class="external text" href="https://en.wikipedia.org/wiki/Surjection" rel="nofollow">surjective function</a>, to map the vector of all relevant occupancies to a range of attack-sets per square. The less bits the attack-set - the closer the blockers, the more those attack-sets are shared by occupancies with different, but redundant outer squares.
</p>
<ul><li> The <b>cardinality</b> of all <b>relevant occupancies</b> is determined by the number of bits to map, varying from five to twelve - thus, the cardinality is the power of two the number of bits, varying from 32 to 4096.</li>
<li> The <b>cardinality</b> of <b>distinct attack-sets</b> is determined by the product of the length of each of the max four direction rays greater than zero (or one). The rook on d4 has 3*4*3*4 = 144 distinct attack-sets, a bishop on a8 has only 7.</li></ul>
<p>The <b>ratio</b> of both cardinalities, that is all <b>relevant occupancies</b> versus the all <b>distinct attack-sets</b> is illustrated below: As a quarter of a board - due to the symmetry, the other squares may deduced by flipping and mirroring. Noticeable is the huge 4096/49 ratio of 2^12 occupied states versus 7 times 7 attack-sets of the edge rooks - 12 bits instead of 6. Those "expensive" squares make constructive collisions very desirable. To become more "minimal" by saving an index bit - to halve down the table for one square or the other.
</p>
<table class="wikitable">
<tr>
<th colspan="5"> bishop on square
</th>
<th rowspan="2"> #occs/<br/>#attset
</th>
<th colspan="5"> rook on square
</th></tr>
<tr>
<th>
</th>
<th> A
</th>
<th> B
</th>
<th> C
</th>
<th> D
</th>
<th>
</th>
<th> A
</th>
<th> B
</th>
<th> C
</th>
<th> D
</th></tr>
<tr>
<th> 8
</th>
<td style="text-align:right;"> 64/7
</td>
<td style="text-align:right;"> 32/6
</td>
<td style="text-align:right;"> 32/10
</td>
<td style="text-align:right;"> 32/12
</td>
<td rowspan="11">
</td>
<th> 8
</th>
<td style="text-align:right;"> 4096/49
</td>
<td style="text-align:right;"> 2048/42
</td>
<td style="text-align:right;"> 2048/70
</td>
<td style="text-align:right;"> 2048/84
</td></tr>
<tr>
<th> 7
</th>
<td style="text-align:right;"> 32/6
</td>
<td style="text-align:right;"> 32/6
</td>
<td style="text-align:right;"> 32/10
</td>
<td style="text-align:right;"> 32/ 12
</td>
<th> 7
</th>
<td style="text-align:right;"> 2048/42
</td>
<td style="text-align:right;"> 1024/36
</td>
<td style="text-align:right;"> 1024/ 60
</td>
<td style="text-align:right;"> 1024/ 72
</td></tr>
<tr>
<th> 6
</th>
<td style="text-align:right;"> 32/10
</td>
<td style="text-align:right;"> 32/10
</td>
<td style="text-align:right;"> 128/40
</td>
<td style="text-align:right;"> 128/ 48
</td>
<th> 6
</th>
<td style="text-align:right;"> 2048/70
</td>
<td style="text-align:right;"> 1024/60
</td>
<td style="text-align:right;"> 1024/100
</td>
<td style="text-align:right;"> 1024/120
</td></tr>
<tr>
<th> 5
</th>
<td style="text-align:right;"> 32/12
</td>
<td style="text-align:right;"> 32/12
</td>
<td style="text-align:right;"> 128/48
</td>
<td style="text-align:right;"> 512/108
</td>
<th> 5
</th>
<td style="text-align:right;"> 2048/84
</td>
<td style="text-align:right;"> 1024/72
</td>
<td style="text-align:right;"> 1024/120
</td>
<td style="text-align:right;"> 1024/144
</td></tr>
<tr>
<td colspan="11">
</td></tr>
<tr>
<th colspan="5"> bishop on square
</th>
<th colspan="5"> rook on square
</th></tr>
<tr>
<th>
</th>
<th> A
</th>
<th> B
</th>
<th> C
</th>
<th> D
</th>
<th>
</th>
<th> A
</th>
<th> B
</th>
<th> C
</th>
<th> D
</th></tr>
<tr>
<th> 8
</th>
<td style="text-align:right;"> 9.14
</td>
<td style="text-align:right;"> 5.33
</td>
<td style="text-align:right;"> 3.20
</td>
<td style="text-align:right;"> 2.67
</td>
<th> 8
</th>
<td style="text-align:right;"> 83.59
</td>
<td style="text-align:right;"> 48.76
</td>
<td style="text-align:right;"> 29.26
</td>
<td style="text-align:right;"> 24.38
</td></tr>
<tr>
<th> 7
</th>
<td style="text-align:right;"> 5.33
</td>
<td style="text-align:right;"> 5.33
</td>
<td style="text-align:right;"> 3.20
</td>
<td style="text-align:right;"> 2.67
</td>
<th> 7
</th>
<td style="text-align:right;"> 48.76
</td>
<td style="text-align:right;"> 28.44
</td>
<td style="text-align:right;"> 17.07
</td>
<td style="text-align:right;"> 14.22
</td></tr>
<tr>
<th> 6
</th>
<td style="text-align:right;"> 3.20
</td>
<td style="text-align:right;"> 3.20
</td>
<td style="text-align:right;"> 3.20
</td>
<td style="text-align:right;"> 2.67
</td>
<th> 6
</th>
<td style="text-align:right;"> 29.26
</td>
<td style="text-align:right;"> 17.07
</td>
<td style="text-align:right;"> 10.24
</td>
<td style="text-align:right;"> 8.53
</td></tr>
<tr>
<th> 5
</th>
<td style="text-align:right;"> 2.67
</td>
<td style="text-align:right;"> 2.67
</td>
<td style="text-align:right;"> 2.67
</td>
<td style="text-align:right;"> 4.74
</td>
<th> 5
</th>
<td style="text-align:right;"> 24.38
</td>
<td style="text-align:right;"> 14.22
</td>
<td style="text-align:right;"> 8.53
</td>
<td style="text-align:right;"> 7.11
</td></tr></table>
<p>The idea to implement minimal perfect hashing by an additional 16-bit indirection turned out to be slower.
</p><p>Recent table sizes were about <b>38 KByte</b> for the bishop attacks, but still about <b>800 KByte</b> for rook attacks. That sounds huge, considering L1 and L2 (L3) cache-sizes and number of cachelines and pages needed - we likely fetch distinct cachelines for each different square or occupancy. On the other hand caches and pages become larger in future processors. And occupancy and squares of the lookups don't change that randomly inside a search that we can still expect a lot of L1-hits. Unfortunately changes in occupancy outside the blockers and therefor not affecting the attack-set will introduce some more cache misses.
</p>
<h3><span class="mw-headline" id="Sample_Code">Sample Code</span></h3>
<p>Anyway, register usage and code size are important issues as well - and here <b>magic bitboards</b> are unbeatable - specially bishopAttacks, with respect to the relative small table.
</p>
<pre>
U64 attacks_table[...]; // ~840K Byte all rook and bishop attacks

struct SMagic {
   U64* ptr;  // pointer to the attack-table for one particular square
   U64 mask;  // to mask of both lines
   U64 magic; // magic 64-bit factor
   int shift; // shift right 
};

SMagic mBishopTbl[64];
SMagic mRookTbl[64];

U64 bishopAttacks(U64 occ, enumSquare sq) {
   U64* aptr = mBishopTbl[sq].ptr;
   occ      &amp;= mBishopTbl[sq].mask;
   occ      *= mBishopTbl[sq].magic;
   occ     &gt;&gt;= mBishopTbl[sq].shift;
   return aptr[occ];
}

U64 rookAttacks(U64 occ, enumSquare sq) {
   U64* aptr = mRookTbl[sq].ptr;
   occ      &amp;= mRookTbl[sq].mask;
   occ      *= mRookTbl[sq].magic;
   occ     &gt;&gt;= mRookTbl[sq].shift;
   return aptr[occ];
}
</pre>
<h1><span class="mw-headline" id="Summary">Summary</span></h1>
<p>The bitboard method for holding a board game appears to have been invented in the mid 1950's, by <a href="Arthur Samuel.html" title="Arthur Samuel">Arthur Samuel</a> and was used in his checkers program. In computer chess bitboards were first described by <a href="Georgy Adelson-Velsky.html" title="Georgy Adelson-Velsky">Georgy Adelson-Velsky</a> et al. in 1967 <sup class="reference" id="cite_ref-15"><a href="#cite note-15">[15]</a></sup>, reprinted 1970 <sup class="reference" id="cite_ref-16"><a href="#cite note-16">[16]</a></sup>. Bitboards were used both in <a href="Kaissa.html" title="Kaissa">Kaissa</a> and independently in <a href="Chess (Program).html" title="Chess (Program)">Chess</a>. The invention and publication of <a href="Rotated Bitboards.html" title="Rotated Bitboards">Rotated Bitboards</a> by <a href="Robert Hyatt.html" title="Robert Hyatt">Robert Hyatt</a> and <a href="Peter Gillgasch.html" title="Peter Gillgasch">Peter Gillgasch</a> with <a href="Ernst A. Heinz.html" title="Ernst A. Heinz">Ernst A. Heinz</a> in the 90s was another milestone in the history of bitboards. While rotated bitboards was the mainstream in bitboard chess programs, <a href="Magic Bitboards.html" title="Magic Bitboards">Magic Bitboards</a> become more populated nowadays. Finally, <a href="Steffan Westcott.html" title="Steffan Westcott">Steffan Westcott's</a> innovations, too expensive with 32-bit <a href="X86.html" title="X86">x86</a> architectures, should be revisited with <a href="X86-64.html" title="X86-64">x86-64</a> and <a href="SIMD and SWAR Techniques.html" title="SIMD and SWAR Techniques">SIMD instructions</a> in mind.
</p>
<hr/>
<h1><span class="mw-headline" id="References">References</span></h1>
<div class="mw-references-wrap mw-references-columns"><ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><a href="#cite ref-1">↑</a></span> <span class="reference-text"><a class="external text" href="http://www.math.tu-dresden.de/num/chess2008/abstracts.pdf.html" rel="nofollow">Workshop Chess and Mathematics</a> (pdf) agenda and abstracts</span>
</li>
<li id="cite_note-2"><span class="mw-cite-backlink"><a href="#cite ref-2">↑</a></span> <span class="reference-text"><a href="Charles Leiserson.html" title="Charles Leiserson">Charles E. Leiserson</a>, <a href="Harald Prokop.html" title="Harald Prokop">Harald Prokop</a>, <a href="Keith H. Randall.html" title="Keith H. Randall">Keith H. Randall</a> (<b>1998</b>) <a class="external text" href="http://supertech.csail.mit.edu/papers/debruijn.pdf.html" rel="nofollow">Using de Bruijn Sequences to Index a 1 in a Computer Word</a> (pdf)</span>
</li>
<li id="cite_note-3"><span class="mw-cite-backlink"><a href="#cite ref-3">↑</a></span> <span class="reference-text"><a class="external text" href="http://groups.google.com/group/rec.games.chess.computer/browse frm/thread/d5dbf08c66e83517.html#" rel="nofollow">bitboard 2^i mod 67 is unique</a> by <a href="Stefan Plenkner.html" title="Stefan Plenkner">Stefan Plenkner</a>, <a href="Computer Chess Forums.html" title="Computer Chess Forums">rec.games.chess.computer</a>, August 6, 1996</span>
</li>
<li id="cite_note-4"><span class="mw-cite-backlink"><a href="#cite ref-4">↑</a></span> <span class="reference-text"><a class="external text" href="http://groups.google.com/group/rec.games.chess.computer/browse frm/thread/871851f83e2c429f.html#" rel="nofollow">bitboard 2^i mod 67 is unique</a> by <a href="Jo%C3%ABl Rivat.html" title="Joël Rivat">Joël Rivat</a>, <a href="Computer Chess Forums.html" title="Computer Chess Forums">rec.games.chess.computer</a>, September 2, 1996</span>
</li>
<li id="cite_note-5"><span class="mw-cite-backlink"><a href="#cite ref-5">↑</a></span> <span class="reference-text"><a class="external text" href="http://groups.google.com/group/rec.games.chess.computer/browse frm/thread/9658009e315021fe.html#" rel="nofollow">bitboard 2^i mod 67 is unique</a> by <a href="Stefan Plenkner.html" title="Stefan Plenkner">Stefan Plenkner</a>, <a href="Computer Chess Forums.html" title="Computer Chess Forums">rec.games.chess.computer</a>, August 7, 1996</span>
</li>
<li id="cite_note-6"><span class="mw-cite-backlink"><a href="#cite ref-6">↑</a></span> <span class="reference-text"><a class="external text" href="https://www.stmintz.com/ccc/index.php?id=252289" rel="nofollow">Re: flood fill attack bitboards</a> by <a href="Steffan Westcott.html" title="Steffan Westcott">Steffan Westcott</a>, <a href="CCC.html" title="CCC">CCC</a>, September 15, 2002</span>
</li>
<li id="cite_note-7"><span class="mw-cite-backlink"><a href="#cite ref-7">↑</a></span> <span class="reference-text"><a class="external text" href="http://www.aoki.ecei.tohoku.ac.jp/arith/mg/algorithm.html.html#fsa pfx" rel="nofollow">Hardware algorithms for arithmetic modules</a> from the ARITH research group, Aoki lab., Tohoku University</span>
</li>
<li id="cite_note-8"><span class="mw-cite-backlink"><a href="#cite ref-8">↑</a></span> <span class="reference-text"><a href="Robert Hyatt.html" title="Robert Hyatt">Robert Hyatt</a> (<b>1999</b>). <i><a class="external text" href="http://www.craftychess.com/hyatt/bitmaps.html.html" rel="nofollow">Rotated Bitmaps, a New Twist on an Old Idea</a></i>. <a href="ICGA Journal.html" title="ICGA Journal">ICCA Journal</a>, <a class="external text" href="http://www.cs.unimaas.nl/icga/journal/contents/content22-4.htm.html" rel="nofollow">Vol. 22, No. 4</a>, pp. 213–222. </span>
</li>
<li id="cite_note-9"><span class="mw-cite-backlink"><a href="#cite ref-9">↑</a></span> <span class="reference-text"><a class="external text" href="http://people.csail.mit.edu/heinz/dt/node8.html.html" rel="nofollow">Rotated Bitboards by Ernst A. Heinz</a></span>
</li>
<li id="cite_note-10"><span class="mw-cite-backlink"><a href="#cite ref-10">↑</a></span> <span class="reference-text"><a href="Trevor Fenner.html" title="Trevor Fenner">Trevor Fenner</a>, <a href="Mark Levene.html" title="Mark Levene">Mark Levene</a> (<b>2008</b>). <i>Move Generation with Perfect Hashing Functions.</i> <a href="ICGA Journal.html" title="ICGA Journal">ICGA Journal</a>, Vol. 31, No. 1, pp. 3-12. ISSN 1389-6911.</span>
</li>
<li id="cite_note-11"><span class="mw-cite-backlink"><a href="#cite ref-11">↑</a></span> <span class="reference-text"><a class="external text" href="http://www.talkchess.com/forum/viewtopic.php?t=20913.html" rel="nofollow">Nice Math - Strange Conclusions</a> by <a href="Gerd Isenberg.html" title="Gerd Isenberg">Gerd Isenberg</a>, <a href="CCC.html" title="CCC">CCC</a></span>
</li>
<li id="cite_note-12"><span class="mw-cite-backlink"><a href="#cite ref-12">↑</a></span> <span class="reference-text"><a href="Lasse Hansen.html" title="Lasse Hansen">Lasse Hansen's</a> <a class="external text" href="http://www.open-aurec.com/wbforum/viewtopic.php?t=5015.html" rel="nofollow">Initial idea</a> from <a href="Computer Chess Forums.html" title="Computer Chess Forums">Winboard Forum</a>, June 14, 2006</span>
</li>
<li id="cite_note-13"><span class="mw-cite-backlink"><a href="#cite ref-13">↑</a></span> <span class="reference-text"><a class="external text" href="http://www.pradu.us/old/Nov27 2008/Buzz/research/magic/Bitboards.pdf.html" rel="nofollow">Magic Move-Bitboard Generation in Computer Chess</a> (pdf) by <a href="Pradu Kannan.html" title="Pradu Kannan">Pradu Kannan</a></span>
</li>
<li id="cite_note-14"><span class="mw-cite-backlink"><a href="#cite ref-14">↑</a></span> <span class="reference-text"><a class="external text" href="http://www.open-aurec.com/wbforum/viewtopic.php?t=5441.html" rel="nofollow">List of magics for bitboard move generation</a> thread started by <a href="Pradu Kannan.html" title="Pradu Kannan">Pradu Kannan</a> from <a href="Computer Chess Forums.html" title="Computer Chess Forums">Winboard Forum</a>, Aug 23, 2006</span>
</li>
<li id="cite_note-15"><span class="mw-cite-backlink"><a href="#cite ref-15">↑</a></span> <span class="reference-text"><a class="external text" href="http://groups.google.com/group/rec.games.chess/browse frm/thread/0e3a93f45ff07d31.html#" rel="nofollow">Early Reference on Bit-Boards</a> by <a href="Tony Warnock.html" title="Tony Warnock">Tony Warnock</a>, October 29, 1994 <a class="external text" href="http://groups.google.com/group/rec.games.chess/topics.html" rel="nofollow">rec.games.chess archive</a></span>
</li>
<li id="cite_note-16"><span class="mw-cite-backlink"><a href="#cite ref-16">↑</a></span> <span class="reference-text"><a href="Georgy Adelson-Velsky.html" title="Georgy Adelson-Velsky">Georgy Adelson-Velsky</a>, <a href="Vladimir Arlazarov.html" title="Vladimir Arlazarov">Vladimir Arlazarov</a>, <a href="Alexander Bitman.html" title="Alexander Bitman">Alexander Bitman</a>, <a href="Alexander Zhivotovsky.html" title="Alexander Zhivotovsky">Alexander Zhivotovsky</a> and <a href="Anatoly Uskov.html" title="Anatoly Uskov">Anatoly Uskov</a> (<b>1970</b>). <i>Programming a Computer to Play Chess</i>. Russian Mathematical Surveys, Vol. 25, pp. 221-262</span>
</li>
</ol></div>
<p><b><a href="Workshop Chess and Mathematics.html" title="Workshop Chess and Mathematics">Up one Level</a></b>
</p>
<!-- 
NewPP limit report
Cached time: 20240722162056
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.106 seconds
Real time usage: 0.835 seconds
Preprocessor visited node count: 822/1000000
Preprocessor generated node count: 1648/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->
</div>
<!-- Saved in parser cache with key oscar70_mw1-mw_:pcache:idhash:3625-0!canonical and timestamp 20240722162055 and revision id 5310
 -->
</div> <div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://www.chessprogramming.org/index.php?title=Efficient_Generation_of_Sliding_Piece_Attacks&amp;oldid=5310">https://www.chessprogramming.org/index.php?title=Efficient_Generation_of_Sliding_Piece_Attacks&amp;oldid=5310</a>"					</div>
<div class="catlinks catlinks-allhidden" data-mw="interface" id="catlinks"></div> <div class="visualClear"></div>
</div>
</div>
<div id="mw-navigation">
<h2>Navigation menu</h2>
<div id="mw-head">
<div aria-labelledby="p-personal-label" class="" id="p-personal" role="navigation">
<h3 id="p-personal-label">Personal tools</h3>
<ul>
<li id="pt-login"><a accesskey="o" href="index.php?title=Special:UserLogin&amp;returnto=Efficient+Generation+of+Sliding+Piece+Attacks&amp;returntoquery=printable%3Dyes.html" title="You are encouraged to log in; however, it is not mandatory [o]">Log in</a></li> </ul>
</div>
<div id="left-navigation">
<div aria-labelledby="p-namespaces-label" class="vectorTabs" id="p-namespaces" role="navigation">
<h3 id="p-namespaces-label">Namespaces</h3>
<ul>
<li class="selected" id="ca-nstab-main"><span><a accesskey="c" href="Efficient Generation of Sliding Piece Attacks.html" title="View the content page [c]">Page</a></span></li>
<li class="new" id="ca-talk"><span><a accesskey="t" href="index.php?title=Talk:Efficient Generation of Sliding Piece Attacks&amp;action=edit&amp;redlink=1.html" rel="discussion" title="Discussion about the content page [t]">Discussion</a></span></li>
</ul>
</div>
<div aria-labelledby="p-variants-label" class="vectorMenu emptyPortlet" id="p-variants" role="navigation">
<h3 id="p-variants-label">
<span>Variants</span>
</h3>
<div class="menu">
<ul>
</ul>
</div>
</div>
</div>
<div id="right-navigation">
<div aria-labelledby="p-views-label" class="vectorTabs" id="p-views" role="navigation">
<h3 id="p-views-label">Views</h3>
<ul>
<li class="selected" id="ca-view"><span><a href="Efficient Generation of Sliding Piece Attacks.html">Read</a></span></li>
<li id="ca-viewsource"><span><a accesskey="e" href="index.php?title=Efficient Generation of Sliding Piece Attacks&amp;action=edit.html" title="This page is protected.
You can view its source [e]">View source</a></span></li>
<li class="collapsible" id="ca-history"><span><a accesskey="h" href="index.php?title=Efficient Generation of Sliding Piece Attacks&amp;action=history.html" title="Past revisions of this page [h]">View history</a></span></li>
</ul>
</div>
<div aria-labelledby="p-cactions-label" class="vectorMenu emptyPortlet" id="p-cactions" role="navigation">
<h3 id="p-cactions-label"><span>More</span></h3>
<div class="menu">
<ul>
</ul>
</div>
</div>
<div id="p-search" role="search">
<h3>
<label for="searchInput">Search</label>
</h3>
<form action="/index.php" id="searchform">
<div id="simpleSearch">
<input accesskey="f" id="searchInput" name="search" placeholder="Search Chessprogramming wiki" title="Search Chessprogramming wiki [f]" type="search"/><input name="title" type="hidden" value="Special:Search"/><input class="searchButton mw-fallbackSearchButton" id="mw-searchButton" name="fulltext" title="Search the pages for this text" type="submit" value="Search"/><input class="searchButton" id="searchButton" name="go" title="Go to a page with this exact name if it exists" type="submit" value="Go"/> </div>
</form>
</div>
</div>
</div>
<div id="mw-panel">
<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="Main Page.html" title="Visit the main page"></a></div>
<div aria-labelledby="p-navigation-label" class="portal" id="p-navigation" role="navigation">
<h3 id="p-navigation-label">Navigation</h3>
<div class="body">
<ul>
<li id="n-mainpage-description"><a accesskey="z" href="Main Page.html" title="Visit the main page [z]">Main page</a></li><li id="n-recentchanges"><a accesskey="r" href="Special:RecentChanges.html" title="A list of recent changes in the wiki [r]">Recent changes</a></li><li id="n-randompage"><a accesskey="x" href="Special:Random.html" title="Load a random page [x]">Random page</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li> </ul>
</div>
</div>
<div aria-labelledby="p-tb-label" class="portal" id="p-tb" role="navigation">
<h3 id="p-tb-label">Tools</h3>
<div class="body">
<ul>
<li id="t-whatlinkshere"><a accesskey="j" href="Special:WhatLinksHere/Efficient Generation of Sliding Piece Attacks.html" title="A list of all wiki pages that link here [j]">What links here</a></li><li id="t-recentchangeslinked"><a accesskey="k" href="Special:RecentChangesLinked/Efficient Generation of Sliding Piece Attacks.html" rel="nofollow" title="Recent changes in pages linked from this page [k]">Related changes</a></li><li id="t-specialpages"><a accesskey="q" href="Special:SpecialPages.html" title="A list of all special pages [q]">Special pages</a></li><li id="t-permalink"><a href="index.php?title=Efficient Generation of Sliding Piece Attacks&amp;oldid=5310.html" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="index.php?title=Efficient Generation of Sliding Piece Attacks&amp;action=info.html" title="More information about this page">Page information</a></li> </ul>
</div>
</div>
</div>
</div>
<div id="footer" role="contentinfo">
<ul id="footer-info">
<li id="footer-info-lastmod"> This page was last edited on 2 July 2018, at 09:38.</li>
<li id="footer-info-copyright">Content is available under <a href="Chessprogramming:About.html" title="Chessprogramming:About">Creative Commons Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)</a> unless otherwise noted.</li>
</ul>
<ul id="footer-places">
<li id="footer-places-privacy"><a href="Chessprogramming:Privacy policy.html" title="Chessprogramming:Privacy policy">Privacy policy</a></li>
<li id="footer-places-about"><a href="Chessprogramming:About.html" title="Chessprogramming:About">About Chessprogramming wiki</a></li>
<li id="footer-places-disclaimer"><a href="Chessprogramming:General disclaimer.html" title="Chessprogramming:General disclaimer">Disclaimers</a></li>
<li id="footer-places-mobileview"><a class="noprint stopMobileRedirectToggle" href="https://www.chessprogramming.org/index.php?title=Efficient_Generation_of_Sliding_Piece_Attacks&amp;printable=yes&amp;mobileaction=toggle_view_mobile">Mobile view</a></li>
</ul>
<ul class="noprint" id="footer-icons">
<li id="footer-copyrightico">
<a href="https://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)" height="31" src="images/cc-by-sa.png" width="88"/></a> </li>
<li id="footer-poweredbyico">
<a href="/www.mediawiki.org/.html"><img alt="Powered by MediaWiki" height="31" src="resources/assets/poweredby_mediawiki_88x31.png" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88"/></a> </li>
</ul>
<div style="clear:both"></div>
</div>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.106","walltime":"0.835","ppvisitednodes":{"value":822,"limit":1000000},"ppgeneratednodes":{"value":1648,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20240722162056","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":43});});</script>
</body>
</html>
