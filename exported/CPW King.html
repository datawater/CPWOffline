<!DOCTYPE html>

<html class="client-nojs" dir="ltr" lang="en">
<head>
<meta charset="utf-8"/>
<title>CPW King - Chessprogramming wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"CPW_King","wgTitle":"CPW King","wgCurRevisionId":9303,"wgRevisionId":9303,"wgArticleId":4846,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"CPW_King","wgRelevantArticleId":4846,"wgRequestId":"Zp7DLOWZo7QkwsW0UTn4ugAAAAw","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgPreferredVariant":"en","wgMFExpandAllSectionsUserOption":false,"wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false}});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"loading","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.options@0bhc5ha",function($,jQuery,require,module){mw.user.options.set([]);});mw.loader.implement("user.tokens@0kthzed",function ( $, jQuery, require, module ) {
mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});/*@nomin*/

});mw.loader.load(["site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link href="/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;printable=1&amp;skin=vector" rel="stylesheet"/>
<script async="" src="/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;printable=1&amp;skin=vector"></script>
<meta content="" name="ResourceLoaderDynamicStyles"/>
<link href="/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;printable=1&amp;skin=vector" rel="stylesheet"/>
<meta content="MediaWiki 1.30.1" name="generator"/>
<meta content="noindex,follow" name="robots"/>
<link href="/images/favicon.ico" rel="shortcut icon"/>
<link href="/opensearch_desc.php" rel="search" title="Chessprogramming wiki (en)" type="application/opensearchdescription+xml"/>
<link href="https://www.chessprogramming.org/api.php?action=rsd" rel="EditURI" type="application/rsd+xml"/>
<link href="/Chessprogramming:About" rel="license"/>
<link href="/index.php?title=Special:RecentChanges&amp;feed=atom" rel="alternate" title="Chessprogramming wiki Atom feed" type="application/atom+xml"/>
<!--[if lt IE 9]><script src="/resources/lib/html5shiv/html5shiv.min.js?40bd4"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-CPW_King rootpage-CPW_King skin-vector action-view"> <div class="noprint" id="mw-page-base"></div>
<div class="noprint" id="mw-head-base"></div>
<div class="mw-body" id="content" role="main">
<a id="top"></a>
<div class="mw-indicators mw-body-content">
</div>
<h1 class="firstHeading" id="firstHeading" lang="en">CPW King</h1>
<div class="mw-body-content" id="bodyContent">
<div class="noprint" id="siteSub">From Chessprogramming wiki</div>
<div id="contentSub"></div>
<div class="mw-jump" id="jump-to-nav">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
</div>
<div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="en"><div class="mw-parser-output"><p><b><a href="Main Page.html" title="Main Page">Home</a> * <a href="Engines.html" title="Engines">Engines</a> * <a href="CPW-Engine.html" title="CPW-Engine">CPW-Engine</a> * CPW_King</b>
</p><p>This is a patch to the <a href="CPW-Engine.html" title="CPW-Engine">CPW-Engine</a>, changing its evaluation function. Modifications include:
</p>
<ul><li> getting rid of <a href="Lazy Evaluation.html" title="Lazy Evaluation">lazy eval</a></li>
<li> using <a href="Evaluation Hash Table.html" title="Evaluation Hash Table">eval hash table</a> as default</li>
<li> modifying <a href="Mobility.html" title="Mobility">mobility</a> functions, so that they will count number of attacks on squares near enemy king as well as the number of attackers</li>
<li> placing those functions in the piece-specific routines, before <a href="King Safety.html" title="King Safety">king safety</a> calculation, so that it can make use of them</li>
<li> adding functions to count attacks by queens</li></ul>
<p>Resulting program plays at the roughly the same strength as regular CPW-Engine, but is much more entertaining to watch. To obtain optimal results, piece/square values fo bishops and knights should be raised a tiny bit.
</p><p>The most obvious drawback of the presented code is that it does not see attackers that are lined up, such as rooks doubled on a file. If You consider making this example into a real program, this is the first thing to change.
</p><p>We need to add the following function to the eval_init.cpp, in order to define squares which are considered worthwhile to attack:
</p>
<pre>
void setSquaresNearKing() {
  for (int i = 0; i &lt; 128; ++i)
    for (int j = 0; j &lt; 128; ++j)
    {

      e.sqNearK[WHITE][i][j] = 0;
      e.sqNearK[BLACK][i][j] = 0;

      if (IS_SQ(i) &amp;&amp;
        IS_SQ(j)) {

        // squares constituting the ring around both kings

        if (j == i + NORTH || j == i + SOUTH ||
          j == i + EAST || j == i + WEST ||
          j == i + NW || j == i + NE ||
          j == i + SW || j == i + SE) {

          e.sqNearK[WHITE][i][j] = 1;
          e.sqNearK[BLACK][i][j] = 1;
        }

        /* squares in front of the white king ring */

        if (j == i + NORTH + NORTH ||
          j == i + NORTH + NE ||
          j == i + NORTH + NW)
          e.sqNearK[WHITE][i][j] = 1;

        // squares in front og the black king ring

        if (j == i + SOUTH + SOUTH ||
          j == i + SOUTH + SE ||
          j == i + SOUTH + SW)
          e.sqNearK[WHITE][i][j] = 1;
      }
    }
}
</pre>
<p>The complete eval.cpp looks as follows:
</p>
<pre>
#include "stdafx.h"
#include "0x88_math.h"
#include "eval.h"
#include "transposition.h"

#define use_eval_hash

/* mobility values for various piece kinds */
int bish_mob[16] = { -10, -4, 0, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 7, 8 };
int rook_mob[16] = { -4,  -2, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4 };
int knight_mob[9] = { -6,  -4, 0, 2, 4, 5, 6, 7, 8 };

/* adjustements of piece value based on the number of own pawns */
int knight_adj[9] = { -20, -16, -12, -8, -4,  0,  4,  8, 12 };
int rook_adj[9] = { 15,  12,   9,  6,  3,  0, -3, -6, -9 };

#define MINOR_ATT 2
#define ROOK_ATT  4
#define QUEEN_ATT 8

/*******************************************************************
*  This struct holds data about certain aspects of evaluation,     *
*  which allows program to print them if desired.                  *
*******************************************************************/

struct eval_vector {
  int MaterialAdjustement[2];
  int Blockages[2];
  int PositionalThemes[2];
  int Mobility[2];
  int KingAttackers[2]; // no. of pieces attacking enemy king
  int KingPressure[2];  // value of king pressure
} v;

/* local lists of pieces and pawns and indexes to them */
U8 pieceList[32];
U8 pieceIndex;
U8 pawnList[32];
U8 pawnIndex;

/* global flag used by mobility/attack detection functions to know
if a piece examined currently is a king attacker */

int isAttacker = 0;

/*****************************************************************************
*                  Fast evaluation (material + pcsq + pawn structure)        *
*****************************************************************************/

int fast_eval() {

  /* fold in incrementally updated values */
  int result = p.PieceMaterial[WHITE] + p.PawnMaterial[WHITE] + p.Pcsq[WHITE]
    - p.PieceMaterial[BLACK] - p.PawnMaterial[BLACK] - p.Pcsq[BLACK];

  /* evaluate pawn structure, remembering that a pawn list must be set */
  result += getPawnScoreNoList();

  /* return score relative to the side to move */
  if (b.stm == BLACK)
    return -result;
  else
    return result;
}


/*****************************************************************************
*                  1. Main evaluation function                               *
*****************************************************************************/

int eval(int alpha, int beta) {
  int result;

  /* probe the evaluatinon hashtable */
  int probeval = tteval_probe();
  if (probeval != INVALID)
    return probeval;

  /* set internal data of the evaluation function */
  eval_setPieceLists();
  eval_clearVector();

  /* sum the incrementally counted material and pcsq values */
  result = p.PieceMaterial[WHITE] + p.PawnMaterial[WHITE] + p.Pcsq[WHITE]
    - p.PieceMaterial[BLACK] - p.PawnMaterial[BLACK] - p.Pcsq[BLACK];

  /* tempo bonus */
  if (b.stm == WHITE)
    result += e.TEMPO;
  else
    result -= e.TEMPO;

  /* add in pawn structure evaluation */
  result += getPawnScore();

  /*******************************************************************
  *  Low material correction - guarding against an illusory material *
  *  advantage.  Program  will not not  expect to  win  having  only *
  *  a single minor piece and no pawns.                              *
  *******************************************************************/

  if ((p.PawnMaterial[WHITE] == 0) &amp;&amp;
    (p.PieceMaterial[WHITE] &lt; 400) &amp;&amp;
    (result &gt; 0))
    return 0;

  if ((p.PawnMaterial[BLACK] == 0) &amp;&amp;
    (p.PieceMaterial[BLACK] &lt; 400) &amp;&amp;
    (result &lt; 0))
    return 0;

  /*******************************************************************
  *  Program will not expect to win having only two knights in case  *
  *  neither  side  has pawns. Please note that this  code  assumes  *
  *  different values for bishop and knight, and eval_init() should  *
  *  take care of that.                                              *
  *******************************************************************/

  if (!p.PawnMaterial[WHITE] &amp;&amp; !p.PawnMaterial[BLACK]) {
    if (p.PieceMaterial[WHITE] == 2 * e.PIECE_VALUE[KNIGHT] &amp;&amp; result &gt; 0)
      result = 0;
    if (p.PieceMaterial[BLACK] == 2 * e.PIECE_VALUE[KNIGHT] &amp;&amp; result &lt; 0)
      result = 0;
  }

  /*******************************************************************
  * Adjusting material value for the various combinations of pieces. *
  * Currently it scores bishop, knight and rook pairs. The first one *
  * gets a bonus, the latter two - a penalty. Please also note that  *
  * adjustements of knight and rook value based on the number of own *
  * pawns on the board are done within the piece-specific routines.  *
  *******************************************************************/

  if (p.PieceCount[WHITE][BISHOP] &gt; 1) v.MaterialAdjustement[WHITE] += e.BISHOP_PAIR;
  if (p.PieceCount[BLACK][BISHOP] &gt; 1) v.MaterialAdjustement[BLACK] += e.BISHOP_PAIR;
  if (p.PieceCount[WHITE][KNIGHT] &gt; 1) v.MaterialAdjustement[WHITE] -= e.P_KNIGHT_PAIR;
  if (p.PieceCount[BLACK][KNIGHT] &gt; 1) v.MaterialAdjustement[BLACK] -= e.P_KNIGHT_PAIR;
  if (p.PieceCount[WHITE][ROOK] &gt; 1) v.MaterialAdjustement[WHITE] -= e.P_ROOK_PAIR;
  if (p.PieceCount[BLACK][ROOK] &gt; 1) v.MaterialAdjustement[BLACK] -= e.P_ROOK_PAIR;


  // penalty for the lack of pawns - added 28.07.2008
  if (p.PieceCount[WHITE][PAWN] == 0) v.MaterialAdjustement[WHITE] -= 16;
  if (p.PieceCount[BLACK][PAWN] == 0) v.MaterialAdjustement[BLACK] -= 16;

  /********************************************************************
  *   Evaluate piece placement. This giant loop calls piece-specific  *
  *   functions which tend to do four things:                         *
  *                                                                   *
  *   (1) they look for the trapped pieces and blockages              *
  *   (2) they look for rooks on (half) open files                    *
  *   (3) they calculate mobility and king safety                     *
  *   (4) they calculate adjustements of material value based on      *
  *      the number of pawns                                          *
  ********************************************************************/

  for (int i = 0; i &lt; pieceIndex; i++) {

    S8 sq = pieceList[i];

    switch (b.color[sq]) {
    case WHITE: {
      switch (b.pieces[sq]) {
      case KNIGHT: wKnightEval(sq); break;
      case BISHOP: wBishopEval(sq); break;
      case ROOK: wRookEval(sq);   break;
      case QUEEN: wQueenEval(sq);  break;
      }
    }
                break;
    case BLACK: {
      switch (b.pieces[sq]) {
      case KNIGHT: bKnightEval(sq); break;
      case BISHOP: bBishopEval(sq); break;
      case ROOK: bRookEval(sq);   break;
      case QUEEN: bQueenEval(sq);  break;
      }
    }
                break;
    }
  }

  /********************************************************************
  *   After  the piece evaluation loop we have the king tropism  data *
  *   in order, so it is time to do full king evaluation. For details *
  *   see comments in wKingEval() function.                           *
  ********************************************************************/

  result += wKingEval(p.KingLoc[WHITE]);
  result -= bKingEval(p.KingLoc[BLACK]);

  /********************************************************************
  *   Pattern evaluation - mainly things interrelated with the pawn   *
  *   position, not fitting elsewhere.                                *
  ********************************************************************/

  blockedCentralPawns(); // don't block central pawns on initial squares
  blockedRooks();        // avoid pseudo-castling which blocks the rook
  slavMistake();         // don't play c4-c5 against Slav / Stonewall
  evalFianchetto();

  /********************************************************************
  *  Fold in data gathered in evaluation vector.                      *
  ********************************************************************/

  result += v.MaterialAdjustement[WHITE];
  result -= v.MaterialAdjustement[BLACK];
  result += v.Blockages[WHITE];
  result -= v.Blockages[BLACK];
  result += v.PositionalThemes[WHITE];
  result -= v.PositionalThemes[BLACK];

  /******************************************************************
  *  Here mobility score is scaled according to the side to move.   *
  *  We  give  more weight to opponent's mobility  to  encourage    *
  *  playing for restraint.                                         *
  ******************************************************************/

  if (sd.myside == WHITE) {
    v.Mobility[BLACK] *= 4;
    v.Mobility[BLACK] /= 3;
  }
  else {
    v.Mobility[WHITE] *= 4;
    v.Mobility[WHITE] /= 3;
  }

  result += v.Mobility[WHITE];
  result -= v.Mobility[BLACK];

  /*******************************************************************
  *  Finally return the score relative to the side to move.          *
  *******************************************************************/

  if (b.stm == BLACK)
    result = -result;

  // save value in the eval tt
  tteval_save(result);

  return result;
}

/***********************************************************************
*                     2. Preparatory routines                          *
***********************************************************************/

void eval_setPieceLists() {

  /***********************************************************************
  * Create  local  lists  of pieces and pawns. This is  done  to  avoid  *
  * looping through the entire board three times: for pawns, for pieces  *
  * and again evaluating mobility if lazy eval does not produce a cutoff.*
  ***********************************************************************/

  pieceIndex = 0;
  pawnIndex = 0;

  for (U8 row = 0; row &lt; 8; row++)
    for (U8 col = 0; col &lt; 8; col++) {

      S8 sq = row * 16 + col;

      if (b.color[sq] != COLOR_EMPTY) {
        if (b.pieces[sq] == PAWN) {
          pawnList[pawnIndex] = sq;
          ++pawnIndex;
        }
        else {
          pieceList[pieceIndex] = sq;
          ++pieceIndex;
        }
      }
    }
}

/***********************************************************************
* This is a reduced version of the previous function, and it creates   *
* only a list of pawns.                                                *
***********************************************************************/

void eval_setPawnLists() {

  pawnIndex = 0;

  for (U8 row = 0; row &lt; 8; row++)
    for (U8 col = 0; col &lt; 8; col++) {

      S8 sq = row * 16 + col;

      if (b.color[sq] != COLOR_EMPTY &amp;&amp;
        b.pieces[sq] == PAWN) {
        pawnList[pawnIndex] = sq;
        ++pawnIndex;
      }
    }
}


void eval_clearVector() {
  v.MaterialAdjustement[WHITE] = 0;
  v.MaterialAdjustement[BLACK] = 0;
  v.PositionalThemes[WHITE] = 0;
  v.PositionalThemes[BLACK] = 0;
  v.KingAttackers[WHITE] = 0;
  v.KingAttackers[BLACK] = 0;
  v.KingPressure[WHITE] = 0;
  v.KingPressure[BLACK] = 0;
  v.Blockages[WHITE] = 0;
  v.Blockages[BLACK] = 0;
  v.Mobility[WHITE] = 0;
  v.Mobility[BLACK] = 0;
}

/************************************************************************
*                    3. King safety evaluation                          *
************************************************************************/

int wKingEval(S8 sq) {
  int result = 0;

  if (p.PieceMaterial[WHITE] &lt; e.ENDGAME_MAT) {
    result += e.endgame_king[sq];
  }
  else {
    result += e.PIECESQUARE[KING][WHITE][sq];
    result += wKingShield();
    result -= scaleAttacks(v.KingPressure[BLACK], v.KingAttackers[BLACK]);

    /* Scale the middlegame king evaluation against remaining enemy material */
    result *= p.PieceMaterial[BLACK];
    result /= e.START_MATERIAL;
  }

  return result;
}

int bKingEval(S8 sq) {
  int result = 0;

  if (p.PieceMaterial[BLACK] &lt; e.ENDGAME_MAT) {
    result += e.endgame_king[sq];
  }
  else {
    result += e.PIECESQUARE[KING][BLACK][sq];
    result += bKingShield();
    result -= scaleAttacks(v.KingPressure[WHITE], v.KingAttackers[WHITE]);

    /* Scale the middlegame king evaluation against remaining enemy material */
    result *= p.PieceMaterial[WHITE];
    result /= e.START_MATERIAL;
  }

  return result;
}

int scaleAttacks(int attack_value, int n_of_attackers) {
  int result;

  switch (n_of_attackers) {
  case 0: result = 0;
  case 1: result = 0;
  case 2: result = attack_value;
  case 3: result = (attack_value * 4) / 3;
  case 4: result = (attack_value * 3) / 2;
  default: result = attack_value * 2;
  }

  return result;
}

int wKingShield() {

  int result = 0;

  /* king on the kingside */
  if (COL(p.KingLoc[WHITE]) &gt; COL_E) {

    if (isPiece(WHITE, PAWN, F2))  result += e.SHIELD_1;
    else if (isPiece(WHITE, PAWN, F3))  result += e.SHIELD_2;

    if (isPiece(WHITE, PAWN, G2))  result += e.SHIELD_1;
    else if (isPiece(WHITE, PAWN, G3))  result += e.SHIELD_2;
    else if (p.PawnsOnFile[WHITE][COL_G] == 0) result -= e.P_NO_SHIELD;

    if (isPiece(WHITE, PAWN, H2))  result += e.SHIELD_1;
    else if (isPiece(WHITE, PAWN, H3))  result += e.SHIELD_2;
    else if (p.PawnsOnFile[WHITE][COL_H] == 0) result -= e.P_NO_SHIELD;
  }

  /* king on the queenside */
  else if (COL(p.KingLoc[WHITE]) &lt; COL_D) {

    if (isPiece(WHITE, PAWN, A2))  result += e.SHIELD_1;
    else if (isPiece(WHITE, PAWN, A3))  result += e.SHIELD_2;
    else if (p.PawnsOnFile[WHITE][COL_A] == 0) result -= e.P_NO_SHIELD;

    if (isPiece(WHITE, PAWN, B2))  result += e.SHIELD_1;
    else if (isPiece(WHITE, PAWN, B3))  result += e.SHIELD_2;
    else if (p.PawnsOnFile[WHITE][COL_B] == 0) result -= e.P_NO_SHIELD;

    if (isPiece(WHITE, PAWN, C2))  result += e.SHIELD_1;
    else if (isPiece(WHITE, PAWN, C3))  result += e.SHIELD_2;
  }

  return result;
}

int bKingShield() {
  int result = 0;

  /* king on the kingside */
  if (COL(p.KingLoc[BLACK]) &gt; COL_E) {
    if (isPiece(BLACK, PAWN, F7))  result += e.SHIELD_1;
    else if (isPiece(BLACK, PAWN, F6))  result += e.SHIELD_2;

    if (isPiece(BLACK, PAWN, G7))  result += e.SHIELD_1;
    else if (isPiece(BLACK, PAWN, G6))  result += e.SHIELD_2;
    else if (p.PawnsOnFile[BLACK][COL_G] == 0) result -= e.P_NO_SHIELD;

    if (isPiece(BLACK, PAWN, H7))  result += e.SHIELD_1;
    else if (isPiece(BLACK, PAWN, H6))  result += e.SHIELD_2;
    else if (p.PawnsOnFile[BLACK][COL_H] == 0) result -= e.P_NO_SHIELD;
  }

  /* king on the queenside */
  else if (COL(p.KingLoc[BLACK]) &lt; COL_D) {
    if (isPiece(BLACK, PAWN, A7))  result += e.SHIELD_1;
    else if (isPiece(BLACK, PAWN, A6))  result += e.SHIELD_2;
    else if (p.PawnsOnFile[BLACK][COL_A] == 0) result -= e.P_NO_SHIELD;

    if (isPiece(BLACK, PAWN, B7))  result += e.SHIELD_1;
    else if (isPiece(BLACK, PAWN, B6))  result += e.SHIELD_2;
    else if (p.PawnsOnFile[BLACK][COL_B] == 0) result -= e.P_NO_SHIELD;

    if (isPiece(BLACK, PAWN, C7))  result += e.SHIELD_1;
    else if (isPiece(BLACK, PAWN, C6))  result += e.SHIELD_2;
  }
  return result;
}

/*********************************************************************************
*                            4. Pawn structure evaluaton                         *
*********************************************************************************/

int getPawnScore() {
  int result;

  /*****************************************************************************
  *   This function wraps hashing mechanism around evalPawnStructure(). Please *
  *   note  that since we use the pawn hashtable, evalPawnStructure() must not *
  *   take into account the piece position.  In a more elaborate program, pawn *
  *   hashtable would contain only the characteristics of pawn structure,  and *
  *   scoring them in conjunction with the piece position would have been done *
  *   elsewhere.                                                               *
  ******************************************************************************/

  int probeval = ttpawn_probe();
  if (probeval != INVALID)
    return probeval;

  result = evalPawnStructure();

  ttpawn_save(result);

  return result;
}

/* a clone of getPawnScore, used in fastEval, when the pawn list is not set */

int getPawnScoreNoList() {
  int result;

  int probeval = ttpawn_probe();
  if (probeval != INVALID)
    return probeval;

  eval_setPawnLists();
  result = evalPawnStructure();

  ttpawn_save(result);

  return result;
}

int evalPawnStructure() {
  int result = 0;

  /* 1. evaluate pawn center */
  result += evalPawnCenter();

  /* 2. evaluate doubled/tripled pawns */
  for (U8 col = 0; col &lt; 8; col++) {
    result -= e.P_MULTI_PAWN[p.PawnsOnFile[WHITE][col]];
    result += e.P_MULTI_PAWN[p.PawnsOnFile[BLACK][col]];
  }

  /* 3. core procedure: loop through pawn list, evaluating each pawn on the board */
  for (U8 i = 0; i &lt; pawnIndex; i++) {

    S8 sq = pawnList[i];

    if (b.color[sq] == WHITE)
      result += wPawnEval(sq);
    else
      result -= bPawnEval(sq);
  }
  return result;
}

int evalPawnCenter() {
  int result = 0;

  if (isPiece(WHITE, PAWN, D4)) {
    if (isPiece(WHITE, PAWN, E4)) result += e.DUO_D4E4;
    if (isPiece(WHITE, PAWN, C4)) result += e.DUO_D4C4;
    if (isPiece(WHITE, PAWN, E3)) result += e.DUO_D4E3;
  }

  if (isPiece(WHITE, PAWN, E4)) {
    if (isPiece(WHITE, PAWN, F4)) result += e.DUO_E4F4;
    if (isPiece(WHITE, PAWN, D3)) result += e.DUO_E4D3;
  }

  if (isPiece(BLACK, PAWN, D5)) {
    if (isPiece(BLACK, PAWN, E5)) result -= e.DUO_D4E4;
    if (isPiece(BLACK, PAWN, C5)) result -= e.DUO_D4C4;
    if (isPiece(BLACK, PAWN, E6)) result -= e.DUO_D4E3;
  }

  if (isPiece(BLACK, PAWN, E5)) {
    if (isPiece(BLACK, PAWN, F5)) result -= e.DUO_E4F4;
    if (isPiece(BLACK, PAWN, D6)) result -= e.DUO_E4D3;
  }

  return result;
}

int wPawnEval(S8 sq) {
  int result = 0;

  /* 1. Evaluate passed pawns, scoring them higher if they are
  protected by friendly pawns */

  if (isWPFree(sq)) {
    if (isWPSupported(sq))
      result += e.w_protected_passer[sq];
    else
      result += e.w_passed_pawn[sq];
  }

  /* 2. Evaluate weak pawns */

  if (isWPWeak(sq)) {
    result += e.w_weak_pawn[sq];
    /* weak pawns on half-open files tend to be even weaker */
    if (p.PawnsOnFile[BLACK][COL(sq)] == 0)
      result -= 4;
  }

  return result;
}

int bPawnEval(S8 sq) {
  int result = 0;

  /* 1. Evaluate passed pawns, scoring them higher if they are
  protected by friendly pawns */

  if (isBPFree(sq)) {
    if (isBPSupported(sq))
      result += e.b_protected_passer[sq];
    else
      result += e.b_passed_pawn[sq];
  }

  /* 2. Evaluate weak pawns */

  if (isBPWeak(sq)) {
    result += e.b_weak_pawn[sq];
    /* weak pawns on half-open files tend to be even weaker */
    if (p.PawnsOnFile[WHITE][COL(sq)] == 0)
      result -= 4;
  }

  return result;
}

int isWPFree(S8 sq) {

  S8 nextSq = sq + NORTH;

  while (IS_SQ(nextSq)) {

    /* either blocked by enemy pawn or doubled */
    if (b.pieces[nextSq] == PAWN)
      return 0;

    if (IS_SQ(nextSq + WEST) &amp;&amp; isPiece(BLACK, PAWN, nextSq + WEST))
      return 0;

    if (IS_SQ(nextSq + EAST) &amp;&amp; isPiece(BLACK, PAWN, nextSq + EAST))
      return 0;

    nextSq += NORTH;
  }

  return 1;
}

int isBPFree(S8 sq) {
  S8 nextSq = sq + SOUTH;

  while (IS_SQ(nextSq)) {

    /* either blocked by enemy pawn or doubled */
    if (b.pieces[nextSq] == PAWN)
      return 0;

    if (IS_SQ(nextSq + WEST) &amp;&amp; isPiece(WHITE, PAWN, nextSq + WEST))
      return 0;

    if (IS_SQ(nextSq + EAST) &amp;&amp; isPiece(WHITE, PAWN, nextSq + EAST))
      return 0;

    nextSq += SOUTH;
  }

  return 1;
}

int isWPWeak(S8 sq) {
  S8 nextSq = sq;

  while (IS_SQ(nextSq)) {

    if (IS_SQ(nextSq + WEST) &amp;&amp; isPiece(WHITE, PAWN, nextSq + WEST))
      return 0;

    if (IS_SQ(nextSq + EAST) &amp;&amp; isPiece(WHITE, PAWN, nextSq + EAST))
      return 0;

    nextSq += SOUTH;
  }

  return 1;
}

int isBPWeak(S8 sq) {
  S8 nextSq = sq;

  while (IS_SQ(nextSq)) {

    if (IS_SQ(nextSq + WEST) &amp;&amp; isPiece(BLACK, PAWN, nextSq + WEST))
      return 0;

    if (IS_SQ(nextSq + EAST) &amp;&amp; isPiece(BLACK, PAWN, nextSq + EAST))
      return 0;

    nextSq += NORTH;
  }

  return 1;
}

/****************************************************************
*  The next two procedures are used in passed pawn evaluation,  *
*  the assumption being that passed pawns that are defended or  *
*  or whose stop square is protected by a friendly pawn tend    *
*  to be stronger.                                              *
*****************************************************************/

int isWPSupported(S8 sq) {
  if (IS_SQ(sq + WEST) &amp;&amp; isPiece(WHITE, PAWN, sq + WEST)) return 1;
  if (IS_SQ(sq + EAST) &amp;&amp; isPiece(WHITE, PAWN, sq + EAST)) return 1;
  if (IS_SQ(sq + SE) &amp;&amp; isPiece(WHITE, PAWN, sq + SE)) return 1;
  if (IS_SQ(sq + SW) &amp;&amp; isPiece(WHITE, PAWN, sq + SW)) return 1;

  return 0;
}

int isBPSupported(S8 sq) {
  if (IS_SQ(sq + WEST) &amp;&amp; isPiece(BLACK, PAWN, sq + WEST)) return 1;
  if (IS_SQ(sq + EAST) &amp;&amp; isPiece(BLACK, PAWN, sq + EAST)) return 1;
  if (IS_SQ(sq + NE) &amp;&amp; isPiece(BLACK, PAWN, sq + NE)) return 1;
  if (IS_SQ(sq + NW) &amp;&amp; isPiece(BLACK, PAWN, sq + NW)) return 1;

  return 0;
}

/************************************************************************************
*                        5. Evaluation of pieces                                    *
************************************************************************************/

void wKnightEval(S8 sq) {

  /* material value adjustement based on the no. of own pawns */
  v.MaterialAdjustement[WHITE] += knight_adj[p.PieceCount[WHITE][PAWN]];

  /* mobility and king attacks calculation */
  v.Mobility[WHITE] += wKnightMob(sq);

  /* trapped or blocking knight */
  switch (sq) {
  case A8: if (isPiece(BLACK, PAWN, A7) || isPiece(BLACK, PAWN, C7)) v.Blockages[WHITE] -= e.P_KNIGHT_TRAPPED_A8; break;
  case H8: if (isPiece(BLACK, PAWN, H7) || isPiece(BLACK, PAWN, F7)) v.Blockages[WHITE] -= e.P_KNIGHT_TRAPPED_A8; break;
  case A7: if (isPiece(BLACK, PAWN, A6) &amp;&amp; isPiece(BLACK, PAWN, B7)) v.Blockages[WHITE] -= e.P_KNIGHT_TRAPPED_A7; break;
  case H7: if (isPiece(BLACK, PAWN, H6) &amp;&amp; isPiece(BLACK, PAWN, G7)) v.Blockages[WHITE] -= e.P_KNIGHT_TRAPPED_A7; break;
  case C3: if (isPiece(WHITE, PAWN, C2) &amp;&amp; isPiece(WHITE, PAWN, D4) &amp;&amp; !isPiece(WHITE, PAWN, E4)) v.Blockages[WHITE] -= e.P_C3_KNIGHT; break;
  }
}

void bKnightEval(S8 sq) {

  /* material value adjustement based on the no. of own pawns */
  v.MaterialAdjustement[BLACK] += knight_adj[p.PieceCount[BLACK][PAWN]];

  /* mobility and king attack calculation */
  v.Mobility[BLACK] += bKnightMob(sq);

  /* trapped or blocking knight */
  switch (sq) {
  case A1: if (isPiece(WHITE, PAWN, A2) || isPiece(WHITE, PAWN, C2)) v.Blockages[BLACK] -= e.P_KNIGHT_TRAPPED_A8; break;
  case H1: if (isPiece(WHITE, PAWN, H2) || isPiece(WHITE, PAWN, F2)) v.Blockages[BLACK] -= e.P_KNIGHT_TRAPPED_A8; break;
  case A2: if (isPiece(WHITE, PAWN, A3) &amp;&amp; isPiece(WHITE, PAWN, B2)) v.Blockages[BLACK] -= e.P_KNIGHT_TRAPPED_A7; break;
  case H2: if (isPiece(WHITE, PAWN, H3) &amp;&amp; isPiece(WHITE, PAWN, G2)) v.Blockages[BLACK] -= e.P_KNIGHT_TRAPPED_A7; break;
  case C6: if (isPiece(BLACK, PAWN, C7) &amp;&amp; isPiece(BLACK, PAWN, D5) &amp;&amp; !isPiece(BLACK, PAWN, E5)) v.Blockages[BLACK] -= e.P_C3_KNIGHT; break;
  }
}

void wBishopEval(S8 sq) {

  /* mobility and king attack calculaion */
  v.Mobility[WHITE] += wBishopMob(sq);

  /* trapped bishop and returning bishop */
  switch (sq) {
  case A7: if (isPiece(BLACK, PAWN, B6)) v.Blockages[WHITE] -= e.P_BISHOP_TRAPPED_A7; break;
  case H7: if (isPiece(BLACK, PAWN, G6)) v.Blockages[WHITE] -= e.P_BISHOP_TRAPPED_A7; break;
  case B8: if (isPiece(BLACK, PAWN, C7)) v.Blockages[WHITE] -= e.P_BISHOP_TRAPPED_A7; break;
  case G8: if (isPiece(BLACK, PAWN, F7)) v.Blockages[WHITE] -= e.P_BISHOP_TRAPPED_A7; break;
  case A6: if (isPiece(BLACK, PAWN, B5)) v.Blockages[WHITE] -= e.P_BISHOP_TRAPPED_A6; break;
  case H6: if (isPiece(BLACK, PAWN, G5)) v.Blockages[WHITE] -= e.P_BISHOP_TRAPPED_A6; break;
  case F1: if (isPiece(WHITE, KING, G1)) v.PositionalThemes[WHITE] += e.RETURNING_BISHOP; break;
  case C1: if (isPiece(WHITE, KING, B1)) v.PositionalThemes[WHITE] += e.RETURNING_BISHOP; break;
  }
}

void bBishopEval(S8 sq) {

  /* mobility and king attack calculation */
  v.Mobility[BLACK] += bBishopMob(sq);

  /* trapped bishop and returning bishop */
  switch (sq) {
  case A2: if (isPiece(WHITE, PAWN, B3)) v.Blockages[BLACK] -= e.P_BISHOP_TRAPPED_A7; break;
  case H2: if (isPiece(WHITE, PAWN, G3)) v.Blockages[BLACK] -= e.P_BISHOP_TRAPPED_A7; break;
  case B1: if (isPiece(WHITE, PAWN, C2)) v.Blockages[BLACK] -= e.P_BISHOP_TRAPPED_A7; break;
  case G1: if (isPiece(WHITE, PAWN, F2)) v.Blockages[BLACK] -= e.P_BISHOP_TRAPPED_A7; break;
  case A3: if (isPiece(WHITE, PAWN, B4)) v.Blockages[BLACK] -= e.P_BISHOP_TRAPPED_A6; break;
  case H3: if (isPiece(WHITE, PAWN, G4)) v.Blockages[BLACK] -= e.P_BISHOP_TRAPPED_A6; break;
  case F8: if (isPiece(BLACK, KING, G8)) v.PositionalThemes[BLACK] += e.RETURNING_BISHOP; break;
  case C8: if (isPiece(BLACK, KING, B8)) v.PositionalThemes[BLACK] += e.RETURNING_BISHOP; break;
  }
}

void wRookEval(S8 sq) {

  /* material value adjustement based on the no. of own pawns */
  v.MaterialAdjustement[WHITE] += rook_adj[p.PieceCount[WHITE][PAWN]];

  /* mobility and king attack calculation */
  v.Mobility[WHITE] += wRookMob(sq);

  /* open and half-open files */
  if (p.PawnsOnFile[WHITE][COL(sq)] == 0) {

    if (p.PawnsOnFile[BLACK][COL(sq)] == 0)
      v.PositionalThemes[WHITE] += e.ROOK_OPEN;
    else
      v.PositionalThemes[WHITE] += e.ROOK_HALF;
  }
}

void bRookEval(S8 sq) {

  /* material value adjustement based on the no. of own pawns */
  v.MaterialAdjustement[BLACK] += rook_adj[p.PieceCount[BLACK][PAWN]];

  /* mobility and king attack calculation */
  v.Mobility[BLACK] += bRookMob(sq);

  /* open and half-open files */
  if (p.PawnsOnFile[BLACK][COL(sq)] == 0) {

    if (p.PawnsOnFile[WHITE][COL(sq)] == 0)
      v.PositionalThemes[BLACK] += e.ROOK_OPEN;
    else
      v.PositionalThemes[BLACK] += e.ROOK_HALF;
  }
}

void wQueenEval(S8 sq) {

  /* mobility and king attack calculation */
  v.Mobility[WHITE] += wQueenMob(sq);

  /* penalize premature developement */
  if (ROW(sq) &gt; ROW_2) {
    if (isPiece(WHITE, KNIGHT, B1)) v.PositionalThemes[WHITE] -= 2;
    if (isPiece(WHITE, BISHOP, C1)) v.PositionalThemes[WHITE] -= 2;
    if (isPiece(WHITE, BISHOP, F1)) v.PositionalThemes[WHITE] -= 2;
    if (isPiece(WHITE, KNIGHT, G1)) v.PositionalThemes[WHITE] -= 2;
  }
}

void bQueenEval(S8 sq) {

  /* mobility and king attack calculation */
  v.Mobility[BLACK] += bQueenMob(sq);

  /* penalize premature developement */
  if (ROW(sq) &lt; ROW_7) {
    if (isPiece(BLACK, KNIGHT, B8)) v.PositionalThemes[BLACK] -= 2;
    if (isPiece(BLACK, BISHOP, C8)) v.PositionalThemes[BLACK] -= 2;
    if (isPiece(BLACK, BISHOP, F8)) v.PositionalThemes[BLACK] -= 2;
    if (isPiece(BLACK, KNIGHT, G8)) v.PositionalThemes[BLACK] -= 2;
  }
}

/**********************************************************************************
*                        6. Mobility and king attack evaluation                   *
**********************************************************************************/

int wKnightMob(S8 sq) {

  isAttacker = 0;
  int localMobility = leaperMobility(WHITE, sq, KNIGHT, MINOR_ATT);
  if (isAttacker)
    ++v.KingAttackers[WHITE];

  return knight_mob[localMobility];
}

int bKnightMob(S8 sq) {

  isAttacker = 0;
  int localMobility = leaperMobility(BLACK, sq, KNIGHT, MINOR_ATT);
  if (isAttacker)
    ++v.KingAttackers[BLACK];

  return knight_mob[localMobility];
}

int wBishopMob(S8 sq) {

  isAttacker = 0;

  int localMobility = sliderMobility(WHITE, sq, NE, MINOR_ATT)
    + sliderMobility(WHITE, sq, NW, MINOR_ATT)
    + sliderMobility(WHITE, sq, SE, MINOR_ATT)
    + sliderMobility(WHITE, sq, SW, MINOR_ATT);

  if (isAttacker)
    ++v.KingAttackers[WHITE];

  return bish_mob[localMobility];
}

int bBishopMob(S8 sq) {

  isAttacker = 0;

  int localMobility = sliderMobility(BLACK, sq, NE, MINOR_ATT)
    + sliderMobility(BLACK, sq, NW, MINOR_ATT)
    + sliderMobility(BLACK, sq, SE, MINOR_ATT)
    + sliderMobility(BLACK, sq, SW, MINOR_ATT);

  if (isAttacker)
    ++v.KingAttackers[BLACK];

  return bish_mob[localMobility];
}

int wRookMob(S8 sq) {

  isAttacker = 0;

  int localMobility = sliderMobility(WHITE, sq, NORTH, ROOK_ATT)
    + sliderMobility(WHITE, sq, SOUTH, ROOK_ATT)
    + sliderMobility(WHITE, sq, EAST, ROOK_ATT)
    + sliderMobility(WHITE, sq, WEST, ROOK_ATT);

  if (isAttacker)
    ++v.KingAttackers[WHITE];

  return rook_mob[localMobility];
}

int bRookMob(S8 sq) {

  isAttacker = 0;

  int localMobility = sliderMobility(BLACK, sq, NORTH, ROOK_ATT)
    + sliderMobility(BLACK, sq, SOUTH, ROOK_ATT)
    + sliderMobility(BLACK, sq, EAST, ROOK_ATT)
    + sliderMobility(BLACK, sq, WEST, ROOK_ATT);

  if (isAttacker)
    ++v.KingAttackers[BLACK];

  return rook_mob[localMobility];
}

// with queen, currently we look for king attacks, not for mobility

int wQueenMob(S8 sq) {

  isAttacker = 0;

  int localMobility = sliderMobility(WHITE, sq, NORTH, QUEEN_ATT)
    + sliderMobility(WHITE, sq, SOUTH, QUEEN_ATT)
    + sliderMobility(WHITE, sq, EAST, QUEEN_ATT)
    + sliderMobility(WHITE, sq, WEST, QUEEN_ATT)
    + sliderMobility(WHITE, sq, NE, QUEEN_ATT)
    + sliderMobility(WHITE, sq, NW, QUEEN_ATT)
    + sliderMobility(WHITE, sq, SE, QUEEN_ATT)
    + sliderMobility(WHITE, sq, SW, QUEEN_ATT);

  if (isAttacker)
    ++v.KingAttackers[WHITE];

  return 0;
}

int bQueenMob(S8 sq) {

  isAttacker = 0;

  int localMobility = sliderMobility(BLACK, sq, NORTH, QUEEN_ATT)
    + sliderMobility(BLACK, sq, SOUTH, QUEEN_ATT)
    + sliderMobility(BLACK, sq, EAST, QUEEN_ATT)
    + sliderMobility(BLACK, sq, WEST, QUEEN_ATT)
    + sliderMobility(BLACK, sq, NE, QUEEN_ATT)
    + sliderMobility(BLACK, sq, NW, QUEEN_ATT)
    + sliderMobility(BLACK, sq, SE, QUEEN_ATT)
    + sliderMobility(BLACK, sq, SW, QUEEN_ATT);

  if (isAttacker)
    ++v.KingAttackers[BLACK];

  return 0;
}

int sliderMobility(U8 color, S8 sq, int vect, int attBonus) {
  int nextSq = sq + vect;
  int result = 0;

  while (IS_SQ(nextSq)) {

    if (e.sqNearK[!color][p.KingLoc[!color]][nextSq]) {
      isAttacker = 1;
      v.KingPressure[color] += attBonus;
    }

    if (b.color[nextSq] != COLOR_EMPTY) {
      if (b.color[nextSq] != color)
        return result + 1;
      return result;
    }

    ++result;

    nextSq = nextSq + vect;
  }

  return result;
}

int leaperMobility(U8 color, S8 sq, char byPiece, int attBonus) {
  S8 nextSq;
  int result = 0;

  for (U8 dir = 0; dir&lt;8; dir++) {
    nextSq = sq + vector[byPiece][dir];

    if (IS_SQ(nextSq) &amp;&amp; b.color[nextSq] != color) {

      /* king attack */
      if (e.sqNearK[!color][p.KingLoc[!color]][nextSq]) {
        isAttacker = 1;
        v.KingPressure[color] += attBonus;
      }
      ++result;
    }
  }

  return result;
}

/***************************************************************************************
*                          7. Pattern detection                                        *
***************************************************************************************/

void blockedCentralPawns() {
  if (isPiece(WHITE, PAWN, D2) &amp;&amp; b.color[D3] != COLOR_EMPTY)
    v.Blockages[WHITE] -= e.P_BLOCK_CENTRAL_PAWN;
  if (isPiece(WHITE, PAWN, E2) &amp;&amp; b.color[E3] != COLOR_EMPTY)
    v.Blockages[WHITE] -= e.P_BLOCK_CENTRAL_PAWN;
  if (isPiece(BLACK, PAWN, D7) &amp;&amp; b.color[D6] != COLOR_EMPTY)
    v.Blockages[BLACK] -= e.P_BLOCK_CENTRAL_PAWN;
  if (isPiece(BLACK, PAWN, E7) &amp;&amp; b.color[E6] != COLOR_EMPTY)
    v.Blockages[BLACK] -= e.P_BLOCK_CENTRAL_PAWN;
}

void blockedRooks() {

  if ((isPiece(WHITE, KING, F1) || isPiece(WHITE, KING, G1)) &amp;&amp;
    (isPiece(WHITE, ROOK, H1) || isPiece(WHITE, ROOK, G1))
    )
    v.Blockages[WHITE] -= e.P_KING_BLOCKS_ROOK;

  if ((isPiece(WHITE, KING, C1) || isPiece(WHITE, KING, B1)) &amp;&amp;
    (isPiece(WHITE, ROOK, A1) || isPiece(WHITE, ROOK, B1))
    )
    v.Blockages[WHITE] -= e.P_KING_BLOCKS_ROOK;

  if ((isPiece(BLACK, KING, F8) || isPiece(BLACK, KING, G8)) &amp;&amp;
    (isPiece(BLACK, ROOK, H8) || isPiece(BLACK, ROOK, G8))
    )
    v.Blockages[BLACK] -= e.P_KING_BLOCKS_ROOK;

  if ((isPiece(BLACK, KING, C8) || isPiece(BLACK, KING, B8)) &amp;&amp;
    (isPiece(BLACK, ROOK, A8) || isPiece(BLACK, ROOK, B8))
    )
    v.Blockages[BLACK] -= e.P_KING_BLOCKS_ROOK;
}

void slavMistake() {
  if (isPiece(WHITE, PAWN, D4) &amp;&amp;
    isPiece(WHITE, PAWN, C5) &amp;&amp;
    isPiece(BLACK, PAWN, D5) &amp;&amp;
    isPiece(BLACK, PAWN, C6))
    v.PositionalThemes[WHITE] -= e.P_SLAV_MISTAKE;

  if (isPiece(BLACK, PAWN, D5) &amp;&amp;
    isPiece(BLACK, PAWN, C4) &amp;&amp;
    isPiece(WHITE, PAWN, D4) &amp;&amp;
    isPiece(WHITE, PAWN, C3))
    v.PositionalThemes[BLACK] -= e.P_SLAV_MISTAKE;
}

void evalFianchetto() {

  if (isPiece(WHITE, PAWN, G3)) {
    if (isPiece(WHITE, BISHOP, G2))
      v.PositionalThemes[WHITE] += e.FIANCHETTO;
    else {
      if (!isPiece(WHITE, BISHOP, F3) &amp;&amp;
        !isPiece(WHITE, BISHOP, H1) &amp;&amp;
        !isPiece(WHITE, BISHOP, H3))
        v.PositionalThemes[WHITE] -= e.P_NO_FIANCHETTO;
    }
  }

  if (isPiece(WHITE, PAWN, B3)) {
    if (isPiece(WHITE, BISHOP, B2))
      v.PositionalThemes[WHITE] += e.FIANCHETTO;
    else {
      if (!isPiece(WHITE, BISHOP, C3) &amp;&amp;
        !isPiece(WHITE, BISHOP, A1) &amp;&amp;
        !isPiece(WHITE, BISHOP, A3))

        v.PositionalThemes[WHITE] -= e.P_NO_FIANCHETTO;
    }
  }

  if (isPiece(BLACK, PAWN, G6)) {
    if (isPiece(BLACK, BISHOP, G7))
      v.PositionalThemes[BLACK] += e.FIANCHETTO;
    else {
      if (!isPiece(BLACK, BISHOP, F6) &amp;&amp;
        !isPiece(BLACK, BISHOP, H8) &amp;&amp;
        !isPiece(BLACK, BISHOP, H6))
        v.PositionalThemes[BLACK] -= e.P_NO_FIANCHETTO;
    }
  }

  if (isPiece(BLACK, PAWN, B6)) {
    if (isPiece(BLACK, BISHOP, B7))
      v.PositionalThemes[BLACK] += e.P_NO_FIANCHETTO;
    else {
      if (!isPiece(BLACK, BISHOP, C6) &amp;&amp;
        !isPiece(BLACK, BISHOP, A8) &amp;&amp;
        !isPiece(BLACK, BISHOP, A6))
        v.PositionalThemes[BLACK] -= e.P_NO_FIANCHETTO;
    }
  }
}

/* determine if two squares lie on the same or neighbouring columns */
int isNearCol(S8 sq1, S8 sq2) {
  U8 c1 = COL(sq1);
  U8 c2 = COL(sq2);
  U8 hor_dist = (U8)abs(c1 - c2);

  if (hor_dist &lt; 2)
    return 1;
  else
    return 0;
}

int isPiece(U8 color, U8 piece, S8 sq) {
  return ((b.pieces[sq] == piece) &amp;&amp; (b.color[sq] == color));
}

/***************************************************************************************
*                          8. Printing eval results                                    *
***************************************************************************************/

void printEval() {
  eval(-30000, 30000);
  printf("------------------------------------------\n");
  printf("Total value (for side to move): %d \n", eval(-INFINITY, INFINITY));
  printf("Material balance    : %d \n", p.PieceMaterial[WHITE] + p.PawnMaterial[WHITE] - p.PieceMaterial[BLACK] - p.PawnMaterial[BLACK]);
  printf("Material adjustement: %d \n", v.MaterialAdjustement[WHITE] - v.MaterialAdjustement[BLACK]);
  printf("Piece/square tables : %d \n", p.Pcsq[WHITE] - p.Pcsq[BLACK]);
  printf("Pawn structure      : %d \n", evalPawnStructure());
  printf("Blockages           : %d \n", v.Blockages[WHITE] - v.Blockages[BLACK]);
  printf("Positional themes   : %d \n", v.PositionalThemes[WHITE] - v.PositionalThemes[BLACK]);
  printf("Mobility: white %d, black %d, total %d \n", v.Mobility[WHITE], v.Mobility[BLACK], v.Mobility[WHITE] - v.Mobility[BLACK]);
  printf("King pressure: white %d, black %d \n", v.KingPressure[WHITE], v.KingPressure[BLACK]);
  printf("King attackers: white %d, black %d \n", v.KingAttackers[WHITE], v.KingAttackers[BLACK]);
  printf("Kings: white %d , black %d, total: %d \n", wKingEval(p.KingLoc[WHITE]), bKingEval(p.KingLoc[BLACK]), wKingEval(p.KingLoc[WHITE]) - bKingEval(p.KingLoc[BLACK]));
  printf("Tempo: ");
  if (b.stm == WHITE) printf("%d", e.TEMPO); else printf("%d", -e.TEMPO);
  printf("\n");
  printf("------------------------------------------\n");
}

</pre>
<p><b><a href="CPW-Engine.html" title="CPW-Engine">Up one Level</a></b>
</p>
<!-- 
NewPP limit report
Cached time: 20240722103036
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.006 seconds
Real time usage: 0.006 seconds
Preprocessor visited node count: 7/1000000
Preprocessor generated node count: 44/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->
</div>
<!-- Saved in parser cache with key oscar70_mw1-mw_:pcache:idhash:4846-0!canonical and timestamp 20240722103036 and revision id 9303
 -->
</div> <div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://www.chessprogramming.org/index.php?title=CPW_King&amp;oldid=9303">https://www.chessprogramming.org/index.php?title=CPW_King&amp;oldid=9303</a>"					</div>
<div class="catlinks catlinks-allhidden" data-mw="interface" id="catlinks"></div> <div class="visualClear"></div>
</div>
</div>
<div id="mw-navigation">
<h2>Navigation menu</h2>
<div id="mw-head">
<div aria-labelledby="p-personal-label" class="" id="p-personal" role="navigation">
<h3 id="p-personal-label">Personal tools</h3>
<ul>
<li id="pt-login"><a accesskey="o" href="index.php?title=Special:UserLogin&amp;returnto=CPW+King&amp;returntoquery=printable%3Dyes.html" title="You are encouraged to log in; however, it is not mandatory [o]">Log in</a></li> </ul>
</div>
<div id="left-navigation">
<div aria-labelledby="p-namespaces-label" class="vectorTabs" id="p-namespaces" role="navigation">
<h3 id="p-namespaces-label">Namespaces</h3>
<ul>
<li class="selected" id="ca-nstab-main"><span><a accesskey="c" href="CPW King.html" title="View the content page [c]">Page</a></span></li>
<li class="new" id="ca-talk"><span><a accesskey="t" href="index.php?title=Talk:CPW King&amp;action=edit&amp;redlink=1.html" rel="discussion" title="Discussion about the content page [t]">Discussion</a></span></li>
</ul>
</div>
<div aria-labelledby="p-variants-label" class="vectorMenu emptyPortlet" id="p-variants" role="navigation">
<h3 id="p-variants-label">
<span>Variants</span>
</h3>
<div class="menu">
<ul>
</ul>
</div>
</div>
</div>
<div id="right-navigation">
<div aria-labelledby="p-views-label" class="vectorTabs" id="p-views" role="navigation">
<h3 id="p-views-label">Views</h3>
<ul>
<li class="selected" id="ca-view"><span><a href="CPW King.html">Read</a></span></li>
<li id="ca-viewsource"><span><a accesskey="e" href="index.php?title=CPW King&amp;action=edit.html" title="This page is protected.
You can view its source [e]">View source</a></span></li>
<li class="collapsible" id="ca-history"><span><a accesskey="h" href="index.php?title=CPW King&amp;action=history.html" title="Past revisions of this page [h]">View history</a></span></li>
</ul>
</div>
<div aria-labelledby="p-cactions-label" class="vectorMenu emptyPortlet" id="p-cactions" role="navigation">
<h3 id="p-cactions-label"><span>More</span></h3>
<div class="menu">
<ul>
</ul>
</div>
</div>
<div id="p-search" role="search">
<h3>
<label for="searchInput">Search</label>
</h3>
<form action="/index.php" id="searchform">
<div id="simpleSearch">
<input accesskey="f" id="searchInput" name="search" placeholder="Search Chessprogramming wiki" title="Search Chessprogramming wiki [f]" type="search"/><input name="title" type="hidden" value="Special:Search"/><input class="searchButton mw-fallbackSearchButton" id="mw-searchButton" name="fulltext" title="Search the pages for this text" type="submit" value="Search"/><input class="searchButton" id="searchButton" name="go" title="Go to a page with this exact name if it exists" type="submit" value="Go"/> </div>
</form>
</div>
</div>
</div>
<div id="mw-panel">
<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="Main Page.html" title="Visit the main page"></a></div>
<div aria-labelledby="p-navigation-label" class="portal" id="p-navigation" role="navigation">
<h3 id="p-navigation-label">Navigation</h3>
<div class="body">
<ul>
<li id="n-mainpage-description"><a accesskey="z" href="Main Page.html" title="Visit the main page [z]">Main page</a></li><li id="n-recentchanges"><a accesskey="r" href="Special:RecentChanges.html" title="A list of recent changes in the wiki [r]">Recent changes</a></li><li id="n-randompage"><a accesskey="x" href="Special:Random.html" title="Load a random page [x]">Random page</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li> </ul>
</div>
</div>
<div aria-labelledby="p-tb-label" class="portal" id="p-tb" role="navigation">
<h3 id="p-tb-label">Tools</h3>
<div class="body">
<ul>
<li id="t-whatlinkshere"><a accesskey="j" href="Special:WhatLinksHere/CPW King.html" title="A list of all wiki pages that link here [j]">What links here</a></li><li id="t-recentchangeslinked"><a accesskey="k" href="Special:RecentChangesLinked/CPW King.html" rel="nofollow" title="Recent changes in pages linked from this page [k]">Related changes</a></li><li id="t-specialpages"><a accesskey="q" href="Special:SpecialPages.html" title="A list of all special pages [q]">Special pages</a></li><li id="t-permalink"><a href="index.php?title=CPW King&amp;oldid=9303.html" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="index.php?title=CPW King&amp;action=info.html" title="More information about this page">Page information</a></li> </ul>
</div>
</div>
</div>
</div>
<div id="footer" role="contentinfo">
<ul id="footer-info">
<li id="footer-info-lastmod"> This page was last edited on 18 December 2018, at 15:46.</li>
<li id="footer-info-copyright">Content is available under <a href="Chessprogramming:About.html" title="Chessprogramming:About">Creative Commons Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)</a> unless otherwise noted.</li>
</ul>
<ul id="footer-places">
<li id="footer-places-privacy"><a href="Chessprogramming:Privacy policy.html" title="Chessprogramming:Privacy policy">Privacy policy</a></li>
<li id="footer-places-about"><a href="Chessprogramming:About.html" title="Chessprogramming:About">About Chessprogramming wiki</a></li>
<li id="footer-places-disclaimer"><a href="Chessprogramming:General disclaimer.html" title="Chessprogramming:General disclaimer">Disclaimers</a></li>
<li id="footer-places-mobileview"><a class="noprint stopMobileRedirectToggle" href="https://www.chessprogramming.org/index.php?title=CPW_King&amp;printable=yes&amp;mobileaction=toggle_view_mobile">Mobile view</a></li>
</ul>
<ul class="noprint" id="footer-icons">
<li id="footer-copyrightico">
<a href="https://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)" height="31" src="images/cc-by-sa.png" width="88"/></a> </li>
<li id="footer-poweredbyico">
<a href="/www.mediawiki.org/.html"><img alt="Powered by MediaWiki" height="31" src="resources/assets/poweredby_mediawiki_88x31.png" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88"/></a> </li>
</ul>
<div style="clear:both"></div>
</div>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.006","walltime":"0.006","ppvisitednodes":{"value":7,"limit":1000000},"ppgeneratednodes":{"value":44,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20240722103036","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":45});});</script>
</body>
</html>
