<!DOCTYPE html>

<html class="client-nojs" dir="ltr" lang="en">
<head>
<meta charset="utf-8"/>
<title>Pre-Fruit Rybka and Crafty - Chessprogramming wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Pre-Fruit_Rybka_and_Crafty","wgTitle":"Pre-Fruit Rybka and Crafty","wgCurRevisionId":9273,"wgRevisionId":9273,"wgArticleId":4835,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Pre-Fruit_Rybka_and_Crafty","wgRelevantArticleId":4835,"wgRequestId":"Zp7Dkl0xYjdSHhMDafgs7AAAAAI","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgPreferredVariant":"en","wgMFExpandAllSectionsUserOption":false,"wgMFDisplayWikibaseDescriptions":{"search":false,"nearby":false,"watchlist":false,"tagline":false}});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"loading","user.tokens":"loading","ext.cite.styles":"ready","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.options@0bhc5ha",function($,jQuery,require,module){mw.user.options.set([]);});mw.loader.implement("user.tokens@0kthzed",function ( $, jQuery, require, module ) {
mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});/*@nomin*/

});mw.loader.load(["ext.cite.a11y","site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link href="/load.php?debug=false&amp;lang=en&amp;modules=ext.cite.styles%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;printable=1&amp;skin=vector" rel="stylesheet"/>
<script async="" src="/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;printable=1&amp;skin=vector"></script>
<meta content="" name="ResourceLoaderDynamicStyles"/>
<link href="/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;printable=1&amp;skin=vector" rel="stylesheet"/>
<meta content="MediaWiki 1.30.1" name="generator"/>
<meta content="noindex,follow" name="robots"/>
<link href="/images/favicon.ico" rel="shortcut icon"/>
<link href="/opensearch_desc.php" rel="search" title="Chessprogramming wiki (en)" type="application/opensearchdescription+xml"/>
<link href="https://www.chessprogramming.org/api.php?action=rsd" rel="EditURI" type="application/rsd+xml"/>
<link href="/Chessprogramming:About" rel="license"/>
<link href="/index.php?title=Special:RecentChanges&amp;feed=atom" rel="alternate" title="Chessprogramming wiki Atom feed" type="application/atom+xml"/>
<!--[if lt IE 9]><script src="/resources/lib/html5shiv/html5shiv.min.js?40bd4"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Pre-Fruit_Rybka_and_Crafty rootpage-Pre-Fruit_Rybka_and_Crafty skin-vector action-view"> <div class="noprint" id="mw-page-base"></div>
<div class="noprint" id="mw-head-base"></div>
<div class="mw-body" id="content" role="main">
<a id="top"></a>
<div class="mw-indicators mw-body-content">
</div>
<h1 class="firstHeading" id="firstHeading" lang="en">Pre-Fruit Rybka and Crafty</h1>
<div class="mw-body-content" id="bodyContent">
<div class="noprint" id="siteSub">From Chessprogramming wiki</div>
<div id="contentSub"></div>
<div class="mw-jump" id="jump-to-nav">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
</div>
<div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="en"><div class="mw-parser-output"><p><b><a href="Main Page.html" title="Main Page">Home</a> * <a href="Organizations.html" title="Organizations">Organizations</a> * <a href="ICGA.html" title="ICGA">ICGA</a> * <a href="ICGA Investigations.html" title="ICGA Investigations">Investigations</a> * <a href="Rybka Controversy.html" title="Rybka Controversy">Rybka Controversy</a> * Pre-Fruit Rybka and Crafty</b>
</p><p>Written by <a href="Robert Hyatt.html" title="Robert Hyatt">Bob Hyatt</a> with significant help from <a href="Mark Watkins.html" title="Mark Watkins">Mark Watkins</a>
</p><p>There was also an ongoing investigation regarding pre-Beta <a href="Rybka.html" title="Rybka">Rybkas</a>. There appears to be no direct <a href="Fruit.html" title="Fruit">Fruit</a> link here, but the evidence is still relevant as it shows a pattern of improper code re-use by the <a href="Vasik Rajlich.html" title="Vasik Rajlich">Rybka author</a>. <a href="Zach Wegner.html" title="Zach Wegner">Zach Wegner</a> had looked at the binary for a pre-fruit version of Rybka, the version that supposedly eventually led to Rybka 1 beta that we have been discussing. He found interesting pieces of code. It seemed relevant to look at this version since we have seen references to the "weaker" version of Rybka, with a sudden "leap to the top" soon after Fruit source became available. The obvious question to ask would be "was that version of Rybka original?" The answer is becoming more clear with investigation.
</p>
<div class="toc" id="toc"><div class="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Copied from Crafty"><span class="tocnumber">1</span> <span class="toctext">Copied from Crafty</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Examples of Evidence"><span class="tocnumber">1.1</span> <span class="toctext">Examples of Evidence</span></a>
<ul>
<li class="toclevel-3 tocsection-3"><a href="#Example 1"><span class="tocnumber">1.1.1</span> <span class="toctext">Example 1</span></a></li>
<li class="toclevel-3 tocsection-4"><a href="#Example 2"><span class="tocnumber">1.1.2</span> <span class="toctext">Example 2</span></a></li>
<li class="toclevel-3 tocsection-5"><a href="#Interlude"><span class="tocnumber">1.1.3</span> <span class="toctext">Interlude</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="#Example 3"><span class="tocnumber">1.1.4</span> <span class="toctext">Example 3</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#Example 4"><span class="tocnumber">1.1.5</span> <span class="toctext">Example 4</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#Example 5"><span class="tocnumber">1.1.6</span> <span class="toctext">Example 5</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#Example 6"><span class="tocnumber">1.1.7</span> <span class="toctext">Example 6</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-10"><a href="#Other Examples"><span class="tocnumber">1.2</span> <span class="toctext">Other Examples</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#General comments"><span class="tocnumber">1.3</span> <span class="toctext">General comments</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#License"><span class="tocnumber">1.4</span> <span class="toctext">License</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-13"><a href="#Tournaments"><span class="tocnumber">2</span> <span class="toctext">Tournaments</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#Source of Executables"><span class="tocnumber">3</span> <span class="toctext">Source of Executables</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#References"><span class="tocnumber">4</span> <span class="toctext">References</span></a></li>
</ul>
</div>
<h1><span class="mw-headline" id="Copied_from_Crafty">Copied from Crafty</span></h1>
<p>In particular, initially, Zach Wegner found two examples of copied code from <a href="Crafty.html" title="Crafty">Crafty</a>, one in some code to ensure <i>en passant</i> was not problematic with obsolete <a href="Edwards%27 Tablebases.html" title="Edwards' Tablebases">Edwards tablebases</a>, and one in checking if a mating score was equal to 99999, when such a score could not possibly be returned by the function-call in question.
</p><p>A curious commonality of repeated zeroing of a structure-element when clearing pawn hash has also been uncovered, though some of the contextual parts differ. The first part of the Evaluation functions also yields evidence of code copied, with EvaluateWinner(), a function of about 100 lines of C code, being identical in Crafty and pre-Beta Rybka.
</p>
<h2><span class="mw-headline" id="Examples_of_Evidence">Examples of Evidence</span></h2>
<ul><li> <a href="Rybka-Crafty Evidence.html" title="Rybka-Crafty Evidence">Rybka-Crafty Evidence</a> - re-use of code to tablebase use in KP vs KP when <i>en passant</i> was possible</li>
<li> <a href="Rybka-Crafty Evidence II.html" title="Rybka-Crafty Evidence II">Rybka-Crafty Evidence II</a> - checking whether the return value of EvaluateMate() was 99999</li>
<li> <a href="Rybka-Crafty Evidence III.html" title="Rybka-Crafty Evidence III">Rybka-Crafty Evidence III</a> - repeated zeroing of an element in a pawn hash structure</li>
<li> <a href="Rybka-Crafty Evidence IV.html" title="Rybka-Crafty Evidence IV">Rybka-Crafty Evidence IV</a> - the first part of the Evaluation functions</li>
<li> <a href="Rybka-Crafty Evidence V.html" title="Rybka-Crafty Evidence V">Rybka-Crafty Evidence V</a> - the EvaluateWinner() function</li>
<li> <a href="Rybka-Crafty Evidence VI.html" title="Rybka-Crafty Evidence VI">Rybka-Crafty Evidence VI</a> - NextMove() and NextEvasions() functions</li></ul>
<h3><span class="mw-headline" id="Example_1">Example 1</span></h3>
<p>First, code from Crafty version 19.0, module "init.c":
</p>
<pre>
  for (i = 0; i &lt; pawn_hash_table_size; i++) {
    (pawn_hash_table + i)-&gt;key = 0;
    (pawn_hash_table + i)-&gt;p_score = 0;
    (pawn_hash_table + i)-&gt;protected = 0;
    (pawn_hash_table + i)-&gt;black_defects_k = 0;
    (pawn_hash_table + i)-&gt;black_defects_q = 0;
    (pawn_hash_table + i)-&gt;white_defects_k = 0;
    (pawn_hash_table + i)-&gt;white_defects_q = 0;
    (pawn_hash_table + i)-&gt;passed_w = 0;
    (pawn_hash_table + i)-&gt;passed_w = 0;
    (pawn_hash_table + i)-&gt;outside = 0;
    (pawn_hash_table + i)-&gt;candidates_w = 0;
    (pawn_hash_table + i)-&gt;candidates_b = 0;
}
</pre>
<p>Do you see the rather obvious bug?
</p><p>Look here:
</p>
<pre>
    (pawn_hash_table + i)-&gt;passed_w = 0;
    (pawn_hash_table + i)-&gt;passed_w = 0;
</pre>
<p>Obviously one of those should be _b to clear the passed pawn flags for black. Notice that any variable that has a white or _w in the name is matched with the same variable with black or _b. A simple bug. What if you found this identical code in a different program? Say, for example, a pre-fruit version of Rybka? What would you conclude?
</p><p>Zach will post a follow-up showing where/how he found this code in one of the pre-fruit versions of Rybka.
</p>
<table class="wikitable">
<tr>
<td>  Edit: Mark Watkins notes that the structure in Rybka is not quite the same, so maybe the Crafty version is incorrect, or some of the PAWN_HASH_ENTRY fields were deleted. In any case, more analysis is needed to clarify exactly what is of interest here. Furthermore, it seems as though this pre-Beta Rybka only zeros some of the fields in the PAWN_HASH_ENTRY (4 bytes from 0x0, 4 bytes from 0x4, 2 bytes from 0x8, 1 byte from 0xf, 1 byte from 0xf [sic], 1 byte from 0xa, 1 byte from 0x11, 1 byte from 0x10), while the Crafty code always seem to ensure that all fields are zeroed.
</td></tr></table>
<p>Further analysis shows that Rybka also clears these fields in three different places, just as Crafty does. Once on initial allocation, and in option.c if the pawn hash size is changed, and finally in utility.c in ClearHashTableScores(). The double zeroing of "passed_w" was fixed in init.c in version 19.1 and in option.c in 19.16, but persisted in utility.c until this whole nomenclature was dumped in version 22.0. Of the three instances in the Rybka executable, two of them have this double zeroing of a specific byte.
</p><p>See <a href="Rybka-Crafty Evidence III.html" title="Rybka-Crafty Evidence III">Rybka-Crafty Evidence III</a> for more details.
</p>
<h3><span class="mw-headline" id="Example_2">Example 2</span></h3>
<p>Here is another one from iterate.c:
</p>
<pre>
  TB_use_ok = 1;
  if (TotalWhitePawns &amp;&amp; TotalBlackPawns) {
    wpawn = FirstOne(WhitePawns);
    bpawn = FirstOne(BlackPawns);
    if (FileDistance(wpawn, bpawn) == 1) {
      if (((Rank(wpawn) == RANK2) &amp;&amp; (Rank(bpawn) &gt; RANK3)) ||
          ((Rank(bpawn) == RANK7) &amp;&amp; (Rank(wpawn) &lt; RANK6)) || EnPassant(1))
        TB_use_ok = 0;
    }
  }
</pre>
<p>Mark Watkins has made a disassembly of the Rybka 1.6 code (64 lines) <a href="File:RYBKA16.EdwardsTBep.txt.html" title="File:RYBKA16.EdwardsTBep.txt">File:RYBKA16.EdwardsTBep.txt</a>
</p><p>That code was added to iterate.c when I first started to use the EGTB files from <a href="Steven Edwards.html" title="Steven Edwards">Steven Edwards</a>. It was not needed after Eugene's files were released on my ftp machine, for several reasons. Eugene's were compressed and then decompressed on the fly as they were probed. Stevens were not. As a result, Eugene's files were __far__ smaller. Steven did not, at least while I was using them, release anything other than 3-4 piece files as they took forever to build (Eugene spent a ton of time optimizing his build speed). Steven did, for me, build krnkr and krbkr. But that was all.
</p><p>Steven's kpkp file had one major short-coming, it did not consider en passant pawn captures. As a result, I had to add the above code to disable EGTB probes if an en passant capture could be a possibility anywhere in the tree. What the code does is to check to see if there are opposite-colored pawns on adjacent files, if one of the pawns is on its own second rank (so that it can move two squares at once), and the other pawn has not yet advanced past its 5th rank so that a double pawn push by the opponent might allow an en passant capture. If all of those were true, I had to disable egtb probes. Once Eugene's egtb files were released, which were first used in Crafty version 16.0, support for the Edwards tablebases was removed. But somehow this small vestige of the old support remained.
</p><p>Mark Watkins pointed out a possible bug in the above that really isn't a bug. The wpawn/bpawn values could be wrong if one side had two pawns, because the FirstOne() call might not choose the correct pawn for the test. But in the Edwards tables, that was not possible. We only had kxkx (where x = pnbrq) or kxxk where one side could have two pawns but the other side has none. If you look at the above code, the first requirement was that both sides have pawns (TotalBlackPawns &amp;&amp; TotalWhitePawns which are two counters that count the respective pawns. If either is zero, this code is skipped since no EP capture would be possible. When the Nalimov data was first made available, after I ran a million tests for Eugene to choose the optimal compression block size, we released the 3-4-5 piece files as a complete set. And the above test would not be appropriate both because he included EP captures in the generation process and because we then had kxpkp where x could also be a pawn, breaking that test in many cases. The conclusion? This code was specifically written to prevent errors when probing Steven's tables. It was inappropriate for Nalimov tables. Crafty v16 and beyond only included support for Nalimov files, and that code was inappropriate. Yes it represents a subtle bug in those versions of Crafty beyond Nalimov. But it was also copied into Rybka 1.6.1. There is no reasonable explanation for someone including this code when using Nalimov tables, other than that the code was copied from a programmer (me) that forgot to remove it from his program when he converted from Edwards to Nalimov. The only advantage is that it provides a clear "fingerprint" as to where the code came from, that it was not original at all.
</p><p>Eventually, I discovered the oversight, removed the code, and in version 23.1 and later it was no longer present. How would a program that did not use the Edwards tablebases at all (since they were not available after Eugene's format came along as I was the primary source for distributing both sets and chose to just handle one) have such a piece of code? Eugene's tables __always__ supported EP.
</p><p>See <a href="Rybka-Crafty Evidence.html" title="Rybka-Crafty Evidence">Rybka-Crafty Evidence</a> for more details.
</p>
<h3><span class="mw-headline" id="Interlude">Interlude</span></h3>
<p>There is a lot of effort going into this investigation. The more we look, the more we find. Zach found the above code since we thought it would be useful to get a feel for the pre-fruit Rybkas structure since the claim has been that Rybka 1 beta took ideas but not code. The structure of Rybka changed __dramatically__ from the early version to the "fruity" version. I have been looking at older versions of Crafty to discover what bugs might have been present for a while, and which would __not__ have been a normal mistake if someone had written their own code (the passed_w twice above is an example).
</p><p>I have pointed out another place or two where there was __very__ unusual code in Crafty. We will post these examples whether or not they appear in pre-fruit Rybka, so that we can see either more evidence of copying, or evidence of original programming to go along with some of the copying.
</p><p>For the record, the pawn hash entry above certainly suggests that in addition, EvaluatePawns(), EvaluateKingSafety() and EvaluatePassedPawns() were also copied since they depended on these values in the pawn hash table...
</p>
<h3><span class="mw-headline" id="Example_3">Example 3</span></h3>
<p>Zach has also noticed that this code, which appeared in versions 18.0 through 19.15, is bogus (this code is in evaluate.c, procedure Evaluate()):
</p>
<pre>
  int ms=EvaluateMate(tree);
  if (ms == 99999) break;
</pre>
<p>EvaluateMate() can __never__ return a value of 99999. So the test is a waste of time. Yet it appears in Rybka 1.6.1. Zach pointed out that this was a giveaway in the El Chinito case which was also found to be a Crafty clone, with the _same_ bug included. This is another red flag as EvaluateMate() is only called from one place, in Evaluate(). And that test is only done one time in Crafty. And in Rybka 1.6.1... So another clear case of where code was copied (and not very smartly, either). This code was left over when EvaluateMate() had some tests in it that could say "do a normal evaluation, just chasing the weaker king to the side is not good enough). It would then return 99999 and that would avoid using the result score and instead do a full normal evaluation. At some point, when optimizing, things were changed so that EvaluateMate() was not called unless it was appropriate, rather than having EvaluateMate() itself determine whether the call was appropriate or not. But another vestige of old code was left in, and then copied, and there is no rational explanation for checking for that specific value since neither EvaluateMate() in Crafty, nor in Rybka 1.6.1 can return that value.
</p><p>See <a href="Rybka-Crafty Evidence II.html" title="Rybka-Crafty Evidence II">Rybka-Crafty Evidence II</a> for more details.
</p>
<h3><span class="mw-headline" id="Example_4">Example 4</span></h3>
<p>In the <a href="Rybka-Crafty Evidence II.html" title="Rybka-Crafty Evidence II">page</a> Mark W. provided, he shows the EvaluateMate() == 99999 bug clearly. But he also shows a __lot__ more without realizing it.
</p>
<table class="wikitable">
<tr>
<td>  Edit: Mark and Zach have now noted that the beginning of the Evaluate function in the pre-Rybka Beta copies from Crafty, including the "can_win" issue below from EvaluateWinner() and EvaluateStalemate(), and also in comparing to 13 pieces left before applying these conditions. See <a href="Rybka-Crafty Evidence IV.html" title="Rybka-Crafty Evidence IV">Rybka-Crafty Evidence IV</a> for more details.
</td></tr></table>
<p>In older versions of Crafty, I had a function EvaluateWinner() which was used to answer the questions (1) Can white win and (2) Can black win? I have a variable, "can_win" that is initially set to 3 (1 = white can win, 2 = black can win, 3 = both can win, and 0 = dead draw). I use EvaluateWinner() to check for obvious draws and then set the corresponding bit to zero if that side has no winning chances at all. For example, KRN vs KR has white a knight up. In a drawn position. Suppose the preceding position was KRNP vs KRPP. You find a way to win both of blacks pawns and lose yours in the process. You are now one pawn better, but left with no chance to win. EvaluateWinner() sets the "can_win" variable so that in the case of KRN vs KR, it will indicate that neither side can win, and the score is pulled drastically toward 0, making Crafty avoid "winning" that pawn, and turning a possible win into a draw.
</p><p>This code is clearly present in Rybka 1.6.1 as well. Yet I have never heard of anyone publicly describing such an algorithm, and more specifically, implementing it exactly as I do inside Crafty with that two-bit flag "can_win". This is yet another example of clear copying code and not ideas. And not of copying code that has a bug, but of copying code that is not going to be written in the same way by another programmer. I have changed the way this works more than once myself. At one point it forced the score to 0.00. But I would rather play a game with KRN vs KR where my opponent can screw up and lose, as opposed to just giving up the knight for nothing and still being in a drawn game but now with little hope of an opponent error. This is somewhat related to "swindle mode" in Crafty, an idea several copied, but which none have implemented the same way I did, for the ones I have looked at.
</p>
<h3><span class="mw-headline" id="Example_5">Example 5</span></h3>
<p>Mark has now examined the assembly language from Rybka's disassembly and compared it to the EvaluateWinner() function. And it has produced an almost perfect match, line by line. See <a href="Rybka-Crafty Evidence V.html" title="Rybka-Crafty Evidence V">here</a> for the full comparison. This represents a pretty significant block of code, and the probability of someone producing this independently is infinitesimal. The purpose of this code was to prevent Crafty from stepping into positions that looked good when you do a normal positional score + material, but which are actually not winnable. It evolved over several years of observations on ICC. I remember one example with Cray Blitz where it beat a master in 1981, the first time a computer had done this in OTB tournament play. We had a pawn left, and our opponent appeared to just throw away his h-pawn (we had a g pawn) in order to leave us with a h pawn + wrong colored bishop. CB recognized this in the eval, and we wanted to catch that case + others in Crafty as it is silly to take the pawn with our g-pawn, leaving us in a dead draw. If you look at the mid 19.x versions of Crafty, and then look inside evaluate.c, you will find this EvaluateWinner() function. And if you read the comments, you can see exactly what kinds of things once caused embarrassment and were fixed. :)
</p><p>Some specifics. Case one, we are just a piece up. In the middlegame, this is likely a winning advantage, but when you drop into a reduced material ending, suddenly that extra piece is not enough. Classic example is KRN vs KR. Ditto for KQN vs KQ. The N is just not enough except for some rare positions. The idea is, then, if you are ahead a piece, don't trade pieces so that you get to the point where you are now in a draw. Also, if you have pawns, then we need to avoid dumping the pawns again converting to the draw. A piece advantage with no pawns is not good.
</p><p>Being an exchange up is even worse. KR vs KB or KR vs KN is not winnable without pawns or some other advantage such as being a pawn down but you have an advanced passed pawn, etc. There are other "blended cases". If one side has a minor and no pawns, and the other side has one pawn, then neither side is going to win since the minor can exchange itself for the pawn. All of this qualified by total material so that KRN vs KP is clearly winnable since the knight can sac itself for the pawn and still leave you with enough material to win. If there are no pieces, you can't win with just a rook pawn, unless you have two of them, one on each side of the board.
</p><p>Rook pawns are problematic in general. If your only pawn is a RP, you had better have a piece (and if the piece is a bishop it had better be the right color) if you are going to have any winning chances.
</p><p>The final exceptions are pretty simple. KR vs K+minor+pawn can not be won by the rook. And could actually be lost with the potential promotion if the rook can't sac itself for the pawn.
</p><p>Note that this function is not an absolute score. It just indicates whether one side (or the other) can win. This is used to modify the score, so that if one side has a scoring advantage according to normal evaluation code, but has no winning chances according to EvaluateWinner() then the score is pulled significantly toward a draw. Not to zero, because we still need to play reasonable chess. So, instead, we just reduce the overall score significantly. If a side has winning chances, and the score favors that side, it is unchanged. If a side has no winning chances, yet the score favors that side, the score is reduced. One should also look at how the score is modified. I divide by 4, which is a big reduction if you are at (say) +300 (KRN vs KR) but end up at +75 which looks like you dropped most of a piece by choosing to enter that particular ending. One could divide by any amount, or scale the score non-linearly, or assign a fixed static score. How likely is it that the same reduction is chosen by two different programmers?
</p><p>What is the probability that someone would develop this code, doing _exactly_ the same tests, in exactly the same order, with exactly the same "holes" (one can look at later versions of this function to see how it has changed in subtle ways as either new examples of embarrassing behaviour or bugs were found and addressed)?? This was clearly a "cut and paste" operation, as were the preceding 4 examples.
</p>
<h3><span class="mw-headline" id="Example_6">Example 6</span></h3>
<p>The NextEvasion() function in pre-Beta Rybka is also the same as in Crafty, with the exception of ValidMove() being omitted. The NextMove() function again has many atypical points in common with Rybka 1.6.1. This structure came from Cray Blitz, although the implementation is different in Crafty, thanks to the differences between C and FORTRAN, and one <b>major</b> difference caused by the Crafty GenerateCheckEvasions() function. This is a legal-move generator that was added in early Crafty versions (it was phased in and improved over several months). When in check, Crafty switches to a legal-move generator, because most moves are illegal coming from the classic pseudo-legal move generators. NextEvasion() has a simpler job to do since there are no legality issues. As a result, it uses only a subset of the normal "phases" (the values given below). There are several unique (specific to crafty) ideas in this code that influence how it works. For example, I pass a pointer to a split block around so that every function will access the proper split block for the thread of execution that is doing the accessing. For the Next* functions, this is very important, because for normal calls to them, from a single thread, we pass the current split block address. But in a parallel search, at a split point, we pass a pointer to the parent split block since the move list has to be shared with other threads splitting at the common split point. The overall structure is therefore quite unique and the SMP/non-SMP code is heavily intertwined. 
</p><p>The Rybka 1.6.1 implementation of these functions do not check the legality of the hash move. This is something that has always been in Crafty, since it is cheap and it helps catch bugs. For example, it made it crystal clear that SMP caused lots of invalid hash moves to be reported, which led to the lockless hash implementation to avoid the out-of-order-write problems that caused the errors. Actually going through a Make()/Unmake() on an illegal move can corrupt the board, so for safety the check has remained. It never reports an invalid move during our testing, unless we manage to break something. In Rybka, it was simply removed as unnecessary. Everything else in the hash move usage is identical.
</p><p>In the second block of code addressed by Mark, the "sort_all_moves" case, again the code is identical. To find the highest score, I start with an initial pessimistic value of -999999. The Rybka 1.6.1 sort also includes this specific value, in addition to matching up exactly with the sort used in Crafty, which is not a particularly efficient one, but we often have no sorting to do and it shines when there are 0, 1 or few things to sort. The probability of two programmers using the same sort implementation, with the same early exit, with the same calculations to order moves is unusual. (Particularly when everyone today, Crafty included, uses SEE to weed out bad captures, but then sorts them on MVV/LVA scores.) Using the old Crafty trick of calling Swap() when value(attacker) &lt; value(captured) and using value(captured) - value(attacker) when the attacker is not more valuable than the captured piece is unusual. And it is present in both programs.
</p><p>In the discussion about the history_moves_2 phase in crafty, here is why I did that. In Crafty's move ordering, I do the following, in ordering moves.
</p><p>(1) try the hash move, if present, before generating any moves at all.
</p><p>(2) generate captures and pick the moves with SEE() &gt;= 0 and sort on those values (in version 19.10, not today). As I do this, it is possible that the hash move was one of those captures. I zero that capture when I discover that capture(i) == hash_move(ply) because it has already been tried.
</p><p>(3) next, I try the killer moves (2 at each ply) before I generate any non-capture moves. And since killers are always non-captures, if I get no cutoff, I want to avoid searching them a second time, along with the hash move which also might not be a capture.
</p><p>(4) next, I generate non-captures, which leaves the bad captures and possibly a killer or hash move on the move list as well.
</p><p>(5) the next step is to look thru the list and select the entry with the highest history score to try next (Crafty tries 4 of these moves, total, before giving up. "4" is an ad hoc number with no basis behind it other than testing.) During this first pass, which is history_moves_1, as I check each move to extract it's history score, I also compare each move to the hash move and the two killer moves. If I find a match, the entry in the move list is zeroed since that move has already been searched once. After a single pass thru the move list for this phase, I have selected the move with the largest history counter, and zeroed any move that matched either the hash move or one of the two killers.
</p><p>(6) the next step is the previously mentioned history_moves_2. Which is exactly the same as history_moves_1, except that I now do not need to compare each move to the history or hash moves, as those have already been removed. This is simply a performance optimization that eliminates 3 compares and 3 branches.
</p><p>Rybka uses this exact structure for it's NextMove() function, something I have not seen in other open-source programs and which is probably unique to Crafty and anyone that has copied this code verbatim. The primary point here is that history_moves_2 checks for 3 history moves and then gives up and drops into the remaining_moves phase. 3 + the original single history move where the hash/killer moves were removed gives a total of 4. 4 is a completely ad-hoc number, but it worked well in those versions of Crafty.
</p><p><a href="Rybka-Crafty Evidence VI.html" title="Rybka-Crafty Evidence VI">Rybka-Crafty Evidence VI</a>
</p>
<h2><span class="mw-headline" id="Other_Examples">Other Examples</span></h2>
<p>There are a couple of other examples where Crafty version 19.x code was copied directly into Rybka 1.6.1. The first is given below. The following strings appear in the Rybka 1.6.1 (you can use the Unix "strings Rybka-1.6.1.exe" command to get to these. They show some output formats, and some positions. If you look in bench.c in Crafty 19.0, you will find these 6 positions, exactly. The first 3 lines are from print statements in bench.c.
</p><p>Rybka 1.6.1:
</p>
<pre>
Total elapsed time: %d
Raw nodes per second: %d
Total nodes: %llu
</pre>
<p>Crafty 19.0:
</p>
<pre>
Print(4095,"Total nodes: " BMF "\n",
Print(4095,"Raw nodes per second: %d\n",
Print(4095,"Total elapsed time: %d\n",
</pre>
<p>Rybka 1.6.1:
</p>
<pre>
r1bqk2r/pp2bppp/2p5/3pP3/P2Q1P2/2N1B3/1PP3PP/R4RK1
2r2rk1/1bqnbpp1/1p1ppn1p/pP6/N1P1P3/P2B1N1P/1B2QPP1/R2R2K1
r3r1k1/ppqb1ppp/8/4p1NQ/8/2P5/PP3PPP/R3R1K1
4b3/p3kp2/6p1/3pP2p/2pP1P2/4K1P1/P3N2P/8
rnbqkb1r/p3pppp/1p6/2ppP3/3N4/2P5/PPP1QPPP/R1B1KB1R
3r1k2/4npp1/1ppr3p/p6P/P2PPPP1/1NR5/5K2/2R5

For the last one above, from bench.c:
strcpy(args[0],"3r1k2/4npp1/1ppr3p/p6P/P2PPPP1/1NR5/5K2/2R5");
(the others are all there as well)
</pre>
<p>The following lines are identical with the "perf command output" which is in option.c:
</p><p>Rybka 1.6.1:
</p>
<pre>
generated/made/unmade %d moves per second
generated/made/unmade %d moves, time=%.2f seconds
generated %d moves per second
generated %d moves, time=%.2f seconds
</pre>
<p>Crafty 19.0:
</p>
<pre>
printf("generated %d moves, time=%.2f seconds\n",
printf("generated %d moves per second\n",
printf("generated/made/unmade %d moves, time=%.2f seconds\n",
printf("generated/made/unmade %d moves per second\n",
</pre>
<p>Those are in option.c around line 2700...
</p><p>This is also there, but it has been changed just a "tad". This is from option.c, "perft" command that walks a tree and produces the "perft value" everyone quotes when doing "perft experiments." This was an original Crafty idea, for reference:
</p><p>Rybka 1.6.1:
</p>
<pre>
usage: verify &lt;depth&gt;
</pre>
<p>Crafty 19.0:
</p>
<pre>
printf("usage: perftest &lt;depth&gt;\n");
</pre>
<p>So here, apparently the "perft" command was changed to a "verify" command in Rybka. But output is the same, as expected. While one can argue "this is not code used in the actual engine while playing a game" and have a valid point, it does show that significant blocks of code were copied, proving that the pre- Rybka-1-beta versions were anything but original code.
</p>
<h2><span class="mw-headline" id="General_comments">General comments</span></h2>
<p>A word on plagiarism vs original but duplicated code. Some believe that two different people could implement a function independently, and produce the same lines of code. While the probability of this does go up as the function becomes simpler, it really is not a reasonable explanation of what has happened here. First, anyone can suspect (and most actually know) that a chess program is a large program by most measures. No, it is not the most complex program around. Linux dwarfs Crafty's source by 100x or more. Ditto for even Microsoft Word(tm). But 50,000 lines of code or more is still quite large and complex. And finding these subtle bugs in two different programs, written exactly the same way, can not be explained away by serendipity. This is plagiarism in its simplest form, where code was copied and the copier did not even bother to look carefully at what he was copying to understand what the code was doing. "It works, I'll take that..." These "bugs" were not intentional in Crafty. Only a couple of intentional bugs were done long ago to expose some that were copying my parallel search code and claiming to have written their own. I stopped doing this years ago once the problem of plagiarism was shown to be one that would not go away no matter what the negative outcome was. But a chess program is a big project, and the concept of "debugged chess program" is an oxymoron. Crafty does not crash. It has played 100's of millions of games thanks to cluster testing. But we clearly have not expunged every bug, because not every bug causes a crash.
</p><p>I will continue to look for these "fingerprint" ideas in Crafty's code, so that we can confirm they exist in Rybka 1.6.1 as well. One might be a coincidence. But several big ones (so far)? Not a chance. And while we are not through, I find it compelling to find bad code that was copied, as opposed to finding good code one could claim to have developed independently. Finding the same code with same bug is really beyond serendipity, and that is the kind of evidence we are carefully looking for. It is really important to realize that the source code of a chess engine is "syntax". What it does and how it does it (transform input to output through search and evaluation) is "semantics" Mapping syntax to semantics is what the programmer does as he writes the source. And for a given function, there are an infinite number of ways to write the function (different syntax) and producing different semantics. Same output, but computed in a different way. Finding identical semantics in two programs is far beyond random chance and shows copying.
</p><p>I hate spending time looking at a version from several years ago, but I would like to see this issue resolved by providing enough evidence that anyone can look at it and draw conclusions with no reasonable doubts remaining.
</p>
<h2><span class="mw-headline" id="License">License</span></h2>
<p>It is not yet ascertained which Crafty version was used, but the version numbers indicate something in early 19.x series, possibly a patchwork job. The user agreement in __main.c__ for these versions of Crafty is quite clear.
</p>
<pre>
*  Crafty, copyright 1996-1999 by Robert M. Hyatt, Ph.D., Associate Professor *
*  of Computer and Information Sciences, University of Alabama at Birmingham. *
*                                                                             *
*  All rights reserved.  No part of this program may be reproduced in any     *
*  form or by any means, for other than your personal use, without the        *
*  express written permission of the author.  This program may not be used in *
*  whole, nor in part, to enter any computer chess competition without        *
*  written permission from the author.  Such permission will include the      *
*  requirement that the program be entered under the name "Crafty" so that    *
*  the program's ancestry will be known.                                      *
*                                                                             *
*  Copies of the source must contain the original copyright notice intact.    *
*                                                                             *
*  Any changes made to this software must also be made public to comply with  *
*  the original intent of this software distribution project.  These          *
*  restrictions apply whether the distribution is being done for free or as   *
*  part or all of a commercial product.  The author retains sole ownership    *
*  and copyright on this program except for 'personal use' explained below.   *
*                                                                             *
*  personal use includes any use you make of the program yourself, either by  *
*  playing games with it yourself, or allowing others to play it on your      *
*  machine,  and requires that if others use the program, it must be clearly  *
*  identified as "Crafty" to anyone playing it (on a chess server as one      *
*  example).  Personal use does not allow anyone to enter this into a chess   *
*  tournament where other program authors are invited to participate.  IE you *
*  can do your own local tournament, with Crafty + other programs, since this *
*  is for your personal enjoyment.  But you may not enter Crafty into an      *
*  event where it will be in competition with other programs/programmers      *
*  without permission as stated previously.                                   *
</pre>
<h1><span class="mw-headline" id="Tournaments">Tournaments</span></h1>
<p>A version of Rybka containing these Crafty code segments competed in <a class="external text" href="http://iggor.110mb.com/aegt.php.html" rel="nofollow">AEGT 3</a> (this link seems ready to disappear -- many things on that page are broken), and the same is likely true for <a class="external text" href="http://www.open-aurec.com/chesswar/Chesswar006/Chesswar006DSt.htm.html" rel="nofollow">Chess War V-VII</a>, <a class="external text" href="http://americanfoot.free.fr/echecs/suisse/sui/sui3top200.htm.html" rel="nofollow">Le Système du Suisse 3</a>, and <a class="external text" href="http://www.vrichey.de/cct6/index table.htm.html" rel="nofollow">CCT6</a>.
</p>
<h1><span class="mw-headline" id="Source_of_Executables">Source of Executables</span></h1>
<p><a href="Olivier Deville.html" title="Olivier Deville">Olivier</a> writes in open-chess <sup class="reference" id="cite_ref-1"><a href="#cite note-1">[1]</a></sup> :
</p>
<table class="wikitable">
<tr>
<td>  I have provided the ICGA secretariat with the pre-Fruit versions of Rybka I have here. These versions were meant to remain private, but I feel I have been cheated, and truth must be known. I am not going to send them to anyone else, though.
<p>Olivier 
</p>
</td></tr></table>
<h1><span class="mw-headline" id="References">References</span></h1>
<div class="mw-references-wrap"><ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><a href="#cite ref-1">↑</a></span> <span class="reference-text"><a class="external text" href="http://www.open-chess.org/viewtopic.php?f=3&amp;t=1175&amp;start=160.html#p11099" rel="nofollow">Re: Programmers Open Letter to ICGA on Rybka/Fruit</a> by <a href="Olivier Deville.html" title="Olivier Deville">Olivier Deville</a>, <a href="Computer Chess Forums.html" title="Computer Chess Forums">OpenChess Forum</a>, March 05, 2011</span>
</li>
</ol></div>
<p><b><a href="Rybka Controversy.html" title="Rybka Controversy">Up one level</a></b>
</p>
<!-- 
NewPP limit report
Cached time: 20240722195956
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.015 seconds
Real time usage: 0.017 seconds
Preprocessor visited node count: 185/1000000
Preprocessor generated node count: 354/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->
</div>
<!-- Saved in parser cache with key oscar70_mw1-mw_:pcache:idhash:4835-0!canonical and timestamp 20240722195956 and revision id 9273
 -->
</div> <div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://www.chessprogramming.org/index.php?title=Pre-Fruit_Rybka_and_Crafty&amp;oldid=9273">https://www.chessprogramming.org/index.php?title=Pre-Fruit_Rybka_and_Crafty&amp;oldid=9273</a>"					</div>
<div class="catlinks catlinks-allhidden" data-mw="interface" id="catlinks"></div> <div class="visualClear"></div>
</div>
</div>
<div id="mw-navigation">
<h2>Navigation menu</h2>
<div id="mw-head">
<div aria-labelledby="p-personal-label" class="" id="p-personal" role="navigation">
<h3 id="p-personal-label">Personal tools</h3>
<ul>
<li id="pt-login"><a accesskey="o" href="index.php?title=Special:UserLogin&amp;returnto=Pre-Fruit+Rybka+and+Crafty&amp;returntoquery=printable%3Dyes.html" title="You are encouraged to log in; however, it is not mandatory [o]">Log in</a></li> </ul>
</div>
<div id="left-navigation">
<div aria-labelledby="p-namespaces-label" class="vectorTabs" id="p-namespaces" role="navigation">
<h3 id="p-namespaces-label">Namespaces</h3>
<ul>
<li class="selected" id="ca-nstab-main"><span><a accesskey="c" href="Pre-Fruit Rybka and Crafty.html" title="View the content page [c]">Page</a></span></li>
<li class="new" id="ca-talk"><span><a accesskey="t" href="index.php?title=Talk:Pre-Fruit Rybka and Crafty&amp;action=edit&amp;redlink=1.html" rel="discussion" title="Discussion about the content page [t]">Discussion</a></span></li>
</ul>
</div>
<div aria-labelledby="p-variants-label" class="vectorMenu emptyPortlet" id="p-variants" role="navigation">
<h3 id="p-variants-label">
<span>Variants</span>
</h3>
<div class="menu">
<ul>
</ul>
</div>
</div>
</div>
<div id="right-navigation">
<div aria-labelledby="p-views-label" class="vectorTabs" id="p-views" role="navigation">
<h3 id="p-views-label">Views</h3>
<ul>
<li class="selected" id="ca-view"><span><a href="Pre-Fruit Rybka and Crafty.html">Read</a></span></li>
<li id="ca-viewsource"><span><a accesskey="e" href="index.php?title=Pre-Fruit Rybka and Crafty&amp;action=edit.html" title="This page is protected.
You can view its source [e]">View source</a></span></li>
<li class="collapsible" id="ca-history"><span><a accesskey="h" href="index.php?title=Pre-Fruit Rybka and Crafty&amp;action=history.html" title="Past revisions of this page [h]">View history</a></span></li>
</ul>
</div>
<div aria-labelledby="p-cactions-label" class="vectorMenu emptyPortlet" id="p-cactions" role="navigation">
<h3 id="p-cactions-label"><span>More</span></h3>
<div class="menu">
<ul>
</ul>
</div>
</div>
<div id="p-search" role="search">
<h3>
<label for="searchInput">Search</label>
</h3>
<form action="/index.php" id="searchform">
<div id="simpleSearch">
<input accesskey="f" id="searchInput" name="search" placeholder="Search Chessprogramming wiki" title="Search Chessprogramming wiki [f]" type="search"/><input name="title" type="hidden" value="Special:Search"/><input class="searchButton mw-fallbackSearchButton" id="mw-searchButton" name="fulltext" title="Search the pages for this text" type="submit" value="Search"/><input class="searchButton" id="searchButton" name="go" title="Go to a page with this exact name if it exists" type="submit" value="Go"/> </div>
</form>
</div>
</div>
</div>
<div id="mw-panel">
<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="Main Page.html" title="Visit the main page"></a></div>
<div aria-labelledby="p-navigation-label" class="portal" id="p-navigation" role="navigation">
<h3 id="p-navigation-label">Navigation</h3>
<div class="body">
<ul>
<li id="n-mainpage-description"><a accesskey="z" href="Main Page.html" title="Visit the main page [z]">Main page</a></li><li id="n-recentchanges"><a accesskey="r" href="Special:RecentChanges.html" title="A list of recent changes in the wiki [r]">Recent changes</a></li><li id="n-randompage"><a accesskey="x" href="Special:Random.html" title="Load a random page [x]">Random page</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li> </ul>
</div>
</div>
<div aria-labelledby="p-tb-label" class="portal" id="p-tb" role="navigation">
<h3 id="p-tb-label">Tools</h3>
<div class="body">
<ul>
<li id="t-whatlinkshere"><a accesskey="j" href="Special:WhatLinksHere/Pre-Fruit Rybka and Crafty.html" title="A list of all wiki pages that link here [j]">What links here</a></li><li id="t-recentchangeslinked"><a accesskey="k" href="Special:RecentChangesLinked/Pre-Fruit Rybka and Crafty.html" rel="nofollow" title="Recent changes in pages linked from this page [k]">Related changes</a></li><li id="t-specialpages"><a accesskey="q" href="Special:SpecialPages.html" title="A list of all special pages [q]">Special pages</a></li><li id="t-permalink"><a href="index.php?title=Pre-Fruit Rybka and Crafty&amp;oldid=9273.html" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="index.php?title=Pre-Fruit Rybka and Crafty&amp;action=info.html" title="More information about this page">Page information</a></li> </ul>
</div>
</div>
</div>
</div>
<div id="footer" role="contentinfo">
<ul id="footer-info">
<li id="footer-info-lastmod"> This page was last edited on 17 December 2018, at 16:40.</li>
<li id="footer-info-copyright">Content is available under <a href="Chessprogramming:About.html" title="Chessprogramming:About">Creative Commons Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)</a> unless otherwise noted.</li>
</ul>
<ul id="footer-places">
<li id="footer-places-privacy"><a href="Chessprogramming:Privacy policy.html" title="Chessprogramming:Privacy policy">Privacy policy</a></li>
<li id="footer-places-about"><a href="Chessprogramming:About.html" title="Chessprogramming:About">About Chessprogramming wiki</a></li>
<li id="footer-places-disclaimer"><a href="Chessprogramming:General disclaimer.html" title="Chessprogramming:General disclaimer">Disclaimers</a></li>
<li id="footer-places-mobileview"><a class="noprint stopMobileRedirectToggle" href="https://www.chessprogramming.org/index.php?title=Pre-Fruit_Rybka_and_Crafty&amp;printable=yes&amp;mobileaction=toggle_view_mobile">Mobile view</a></li>
</ul>
<ul class="noprint" id="footer-icons">
<li id="footer-copyrightico">
<a href="https://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)" height="31" src="images/cc-by-sa.png" width="88"/></a> </li>
<li id="footer-poweredbyico">
<a href="/www.mediawiki.org/.html"><img alt="Powered by MediaWiki" height="31" src="resources/assets/poweredby_mediawiki_88x31.png" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88"/></a> </li>
</ul>
<div style="clear:both"></div>
</div>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.015","walltime":"0.017","ppvisitednodes":{"value":185,"limit":1000000},"ppgeneratednodes":{"value":354,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20240722195956","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":43});});</script>
</body>
</html>
